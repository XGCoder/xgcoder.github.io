<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XG</title>
  <icon>https://www.gravatar.com/avatar/ce2962bb1eef370d3dc0e19211d3ae79</icon>
  
  <link href="http://zxn.wiki/atom.xml" rel="self"/>
  
  <link href="http://zxn.wiki/"/>
  <updated>2021-09-14T12:43:15.270Z</updated>
  <id>http://zxn.wiki/</id>
  
  <author>
    <name>赵小嘎</name>
    <email>xggcoder@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>技术学习</title>
    <link href="http://zxn.wiki/2021/09/14/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    <id>http://zxn.wiki/2021/09/14/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-09-14T06:25:35.000Z</published>
    <updated>2021-09-14T12:43:15.270Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一课程-仓位管理"><a href="#第一课程-仓位管理" class="headerlink" title="第一课程 仓位管理"></a>第一课程 仓位管理</h3><p>最小白的方式  10W以下3层仓  10W以上5层仓 </p><ol><li>建仓资金  2–2.5层仓位 </li><li>波段资金  2.5 - 3层仓位 </li></ol><p>操作逻辑:</p><blockquote></blockquote><p>趋势或者形态在低位时操作:<br>可以小仓介入主动买套,在支撑位附近或者破了支撑位后进入第一仓,第二仓继续在下一个趋势或者支撑位埋伏这是建仓资金,当跌破二层建仓建仓位  并且放量下跌时波段资金上场,博反弹(或者可以等止跌信号) 有利润就出,但是当跌破波段资金入场价位时,及时止损,保证波段资金安全</p><blockquote></blockquote><p>趋势或者形态在高位时操作:<br>建仓资金当备用,波段资金上场,放量下跌时吃反弹,高位有利润就跑,如果担心卖飞,可以分批止盈,锁住利润,等待放量下跌,继续进场</p><p>引用之前群聊记录:</p><blockquote></blockquote><p>10W元，分5仓，一仓2W。<br>二仓4W，规划为波段资金。<br>三仓6W，规划为建仓资金。</p><blockquote></blockquote><p>首先来讲解这三仓6W，怎么玩：<br>比如买ICP，<br>第一仓现价62买入2W元，继续跌60附近，买入第二仓。继续跌58附近买入第三仓，（注意，这里压根用不到波段资金）。<br>那么58附近买入的，反弹60就出，第三仓抄的资金就出来了，把前面两仓抄的，成本就均在60附近，这两仓做底仓。继续跌，继续用刚出来的第三仓2W元，来做小波段，快进快出。比如又跌58，抄入，59我就跑，只为降低前面二仓的成本。</p><blockquote></blockquote><p>波段资金：二层仓4W元，怎么用？大跌的时候，才启动。比如现在跌到53，那么我分两仓梭哈进去。反弹55～56，我就止盈跑出来。如果53梭哈，继续跌51，不用考虑，止损割掉，保证这二层仓4W元的资金安全。</p><h3 id="第二课程-量能-压力-支撑-趋势线"><a href="#第二课程-量能-压力-支撑-趋势线" class="headerlink" title="第二课程  量能  压力 支撑  趋势线"></a>第二课程  量能  压力 支撑  趋势线</h3><h4 id="量能"><a href="#量能" class="headerlink" title="量能"></a>量能</h4><blockquote></blockquote><p>最能反应市场供需关系和衡量成交关系的就是量能,K线指标中的OBV,每个K线对应一个量能柱,当某个量柱明显高于其他量柱时,同时K线有剧烈的波动此时称为 “放量” 反之称之为”缩量”</p><h4 id="压力-支撑-趋势线"><a href="#压力-支撑-趋势线" class="headerlink" title="压力 支撑  趋势线"></a>压力 支撑  趋势线</h4><blockquote></blockquote><p>压力支撑可以根据之前的K线进行预先判断<br>在上涨趋势中如果某个位置放量上涨,同时多次下跌都没有跌破开盘价后者最低价,那么这个位置就算是一个有效支撑,背后逻辑是主力在此处大量买入,不允许看到价格跌破自己的成本价所以会有护盘操作,从而形成支撑</p><blockquote></blockquote><p>当价格向下波动时,如果某个位置碰触支撑位向上反弹时,多次测试某个位置都没有突破上去,那这个位置算是一个压力,背后逻辑是之前这个位置有大量的买盘被套牢,现在价格回到成本价有巨量抛盘,导致价格冲突不上去,从而形成压力<br>两个支撑或者三个支撑线的连线 形成了趋势线,一般在这个位置有很大的支撑不容易被打破,反之是压力线,不容易被突破</p><h3 id="第三课程-平台-箱体-形态"><a href="#第三课程-平台-箱体-形态" class="headerlink" title="第三课程  平台  箱体  形态"></a>第三课程  平台  箱体  形态</h3><blockquote></blockquote><p>某个压力位或者支撑位多空打架横盘时,称之为平台整理<br>价格在某个支撑位和压力位之间来回波动时,这个区间称为箱体区间<br>多个K线组合再根据不同趋势判断,形成不同形态,用来预判后期走势和大概价格区间(跳过基础,在后面)</p><h4 id="形态之K线基础"><a href="#形态之K线基础" class="headerlink" title="形态之K线基础"></a>形态之K线基础</h4><p>首先，K线共有48种形态，其中阳线占24种，阴线占24种。两者在形态上差不多，只是一为阳一为阴，阳涨，阴跌</p><p>阳线主要分为小阳线、中阳线、大阳线和阳十字星。<br><img src="https://i.loli.net/2021/09/14/CDc15vytzguEVaO.jpg" alt="阳线总类.jpg"></p><p>1.阳十字星：波动很小，开盘价与收盘价极其接近，收盘价略高于开盘价。<br>阳十字星的出现，表明行情正处于混乱不明的阶段，后市的涨跌无法预测，此时要根据其前期Ｋ线组合的形状以及当时所处的价位区域综合判断。<br><img src="https://i.loli.net/2021/09/14/MRmr57fz9Vy1Gpi.jpg" alt="阳十字星.jpg"></p><p>2.小阳线：波动范围比较阳十字星增大，多头稍占上风，但上攻乏力，表明行情发展扑朔迷离。<br><img src="https://i.loli.net/2021/09/14/8CDelrB3a42gAJE.jpg" alt="小阳线.jpg"></p><p>3.中阳线：买方力量大于卖方，买方占有优势。<br><img src="https://i.loli.net/2021/09/14/SYwqbLlyXvjeZU1.jpg" alt="中阳线"></p><p>4.大阳线：从一开盘，买方就积极进攻，买方发挥最大力量始终占优势，使价格一路上扬。<br>阳线实体越大表示买盘越强，一般后市会涨。<br>下影线越长说明买盘越强，后市一般会涨。<br>上影线越长说明卖盘也强，后市一般会跌。<br><img src="https://i.loli.net/2021/09/14/FQeN7KxYL8AmpWt.jpg" alt="大阳线.jpg"></p><p>阴线主要分为大阴线、中阴线、小阴线和阴十字星。<br><img src="https://i.loli.net/2021/09/14/3MyQsmxREiCweJv.jpg" alt="阴线总类.jpg"></p><p>1.阴十字星：阴十字与阳十字星相似，只是收盘价格略低于开盘价格。表明行情疲软，发展方向不明。<br><img src="https://i.loli.net/2021/09/14/HecIM3PsVohUWCN.jpg" alt="阴十字星.jpg"></p><p>2.小阴线：空方呈打压态势，但力度不大。<br><img src="https://i.loli.net/2021/09/14/lzaFJx1HtejwUAM.jpg" alt="小阴线.jpg"></p><p>3.中阴线： 空头势力强大，卖方力量大于买方，卖方占有优势，价格最终下跌收盘。<br> <img src="https://i.loli.net/2021/09/14/X3rWSuFpsVbNKPJ.jpg" alt="中阴线"></p><p>4.大阴线：空头占据绝对优势，在交易过程中，随着卖方力量的增加，买方不愿追逐高价，卖方渐居主动，币价下跌。<br>阴线的实体越大，表示卖盘越强，一般后市会跌。<br>下影线越长说明买盘越强，后市一般会涨。<br>上影线越长说明卖盘越强，后市一般还会跌。<br><img src="https://i.loli.net/2021/09/14/iSG14Ae9TztO5JQ.jpg" alt="大阴线.jpg"></p><h4 id="形态之头肩顶-头肩底"><a href="#形态之头肩顶-头肩底" class="headerlink" title="形态之头肩顶 头肩底"></a>形态之头肩顶 头肩底</h4><p>稍后补充</p><h4 id="形态之真假突破"><a href="#形态之真假突破" class="headerlink" title="形态之真假突破"></a>形态之真假突破</h4><p>稍后补充</p><h3 id="第四课程-买卖技巧和策略-止盈-止损"><a href="#第四课程-买卖技巧和策略-止盈-止损" class="headerlink" title="第四课程 买卖技巧和策略  止盈 止损"></a>第四课程 买卖技巧和策略  止盈 止损</h3><p>量能为王,指标滞后 !  切记 是底部墨迹,墨迹不是底 </p><p>反复练习仓位管理, 反复练习交易策略, 上涨不买,震荡不买</p><p>每天要做的事：降低持仓成本，止盈空仓，等待第二天机会</p><p>高位操作就是打一枪就跑，保持每天有利润就好，真正赚钱，是在大跌时操作</p><p>养出自己的交易策略和模式，追求利润的同时，也意味着风险，既要做到既追求利润，又降低风险</p><p>持仓筹码买点、卖点，严格按照支撑和压力，逢低就吸，逢高就抛，做到不贪高，不贪底</p><h3 id="第五课程-实盘技巧"><a href="#第五课程-实盘技巧" class="headerlink" title="第五课程 实盘技巧"></a>第五课程 实盘技巧</h3><p>上涨没量，自然就跌。<br>下跌没量，自然就涨。</p><p>结合K线形态,判断是不是底部</p><p>稍后补充</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;第一课程-仓位管理&quot;&gt;&lt;a href=&quot;#第一课程-仓位管理&quot; class=&quot;headerlink&quot; title=&quot;第一课程 仓位管理&quot;&gt;&lt;/a&gt;第一课程 仓位管理&lt;/h3&gt;&lt;p&gt;最小白的方式  10W以下3层仓  10W以上5层仓 &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;建</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>lldb调试命令</title>
    <link href="http://zxn.wiki/2017/04/10/lldb%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4/"/>
    <id>http://zxn.wiki/2017/04/10/lldb%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4/</id>
    <published>2017-04-10T13:56:03.000Z</published>
    <updated>2021-06-25T02:55:08.396Z</updated>
    
    <content type="html"><![CDATA[<p>这里简单记录几个好用的lldb调试命名<br>用户查看app结构相当方便</p><p><strong>pvc命令</strong><br>查看当前页面是什么控制器</p><p><strong>pviews</strong><br>查看当前控制器有哪些view层级</p><p><strong>border</strong><br>给当前的view或者图片图层/背景添加一个边框 可以在模拟器中看到效果不用再编译运行</p><p><strong>unborder</strong><br>去除border 的图层添加</p><p><strong>caflush</strong><br>debug控制器中刷新当前模拟器的图层 不用重新编译</p><p><strong>presponder</strong><br>打印响应链  查看当前控件的响应顺序</p><p><strong>taglog</strong><br>点击屏幕程序会暂停,会打印到你所触摸的view</p><p><strong>pclass</strong><br>打印当前类的继承关系</p><p><strong>bmessage</strong><br>当控制器没有实现拿个方法时用这个命令可以在运行时给程序添加断点</p><p><strong>hide/show</strong><br>遮盖或者隐藏哪个view</p><p><strong>pinternals</strong><br>查看当前控制器的所有属性,包括私有的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里简单记录几个好用的lldb调试命名&lt;br&gt;用户查看app结构相当方便&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pvc命令&lt;/strong&gt;&lt;br&gt;查看当前页面是什么控制器&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pviews&lt;/strong&gt;&lt;br&gt;查看当前控制器有哪些view层级&lt;/p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Mach-O格式分析</title>
    <link href="http://zxn.wiki/2017/04/05/Mach-O%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/"/>
    <id>http://zxn.wiki/2017/04/05/Mach-O%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/</id>
    <published>2017-04-05T12:22:51.000Z</published>
    <updated>2021-06-25T02:55:08.394Z</updated>
    
    <content type="html"><![CDATA[<p>不同操作系统的k而执行文件格式都不相同,例如:</p><p><code>Linux</code>下可执行文件的格式 –&gt; <code>ELF</code><br><code>windows</code>的可执行文件的格式 –&gt; <code>PE32／PE32+</code><br><code>OS X和iOS</code>的可执行文件的格式 –&gt; <code>Mach-O</code></p><p>&lt;Excerpt in index | 首页摘要&gt;<br> <a id="more"></a><br>&lt;The rest of contents | 余下全文&gt;</p><p>在这里先简单谈一谈 <code>Mach-O</code>格式<br><code>Mach-O</code>格式包括了 <code>Header</code>、<code>Load commands</code>、<code>Data</code></p><p><img src="/img/Mach-O.jpg" alt=""></p><h3 id="Header-的结构"><a href="#Header-的结构" class="headerlink" title="Header 的结构"></a>Header 的结构</h3><p><code>Mach－O</code>的头部，使得可以快速确认一些信息，比如当前文件用于32位还是64位，对应的处理器是什么、文件类型是什么</p><p>我们可以使用<code>MachOView</code>（是一个查看MachO 格式文件信息的开源工具）来查看逆向后的WeChat.decrypted文件的具体格式如何</p><p><img src="/img/mach-oHeader.png" alt=""></p><p>下面看一下 header的数据结构:</p><p>32位结构:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct mach_header &#123;</span><br><span class="line">    uint32_t    magic;        &#x2F;* mach magic number identifier *&#x2F;</span><br><span class="line">    cpu_type_t    cputype;    &#x2F;* cpu specifier *&#x2F;</span><br><span class="line">    cpu_subtype_t    cpusubtype;    &#x2F;* machine specifier *&#x2F;</span><br><span class="line">    uint32_t    filetype;    &#x2F;* type of file *&#x2F;</span><br><span class="line">    uint32_t    ncmds;        &#x2F;* number of load commands *&#x2F;</span><br><span class="line">    uint32_t    sizeofcmds;    &#x2F;* the size of all the load commands *&#x2F;</span><br><span class="line">    uint32_t    flags;        &#x2F;* flags *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>64位架构:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct mach_header_64 &#123;</span><br><span class="line">    uint32_t    magic;        &#x2F;* mach magic number identifier *&#x2F;</span><br><span class="line">    cpu_type_t    cputype;    &#x2F;* cpu specifier *&#x2F;</span><br><span class="line">    cpu_subtype_t    cpusubtype;    &#x2F;* machine specifier *&#x2F;</span><br><span class="line">    uint32_t    filetype;    &#x2F;* type of file *&#x2F;</span><br><span class="line">    uint32_t    ncmds;        &#x2F;* number of load commands *&#x2F;</span><br><span class="line">    uint32_t    sizeofcmds;    &#x2F;* the size of all the load commands *&#x2F;</span><br><span class="line">    uint32_t    flags;        &#x2F;* flags *&#x2F;</span><br><span class="line">    uint32_t    reserved;    &#x2F;* reserved *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>32位和64位架构的头文件，没有太大的区别，只是64位多了一个保留字段</p><ul><li><code>magic</code>：  魔数，用于快速确认该文件用于64位还是32位</li><li><code>cputype</code>：CPU类型，比如 arm</li><li><code>cpusubtype</code>：对应的具体类型，比如arm64、armv7</li><li><code>filetype</code>：文件类型，比如可执行文件、库文件、Dsym文件，demo中是2 <code>MH_EXECUTE</code>，代表可执行文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F; *</span><br><span class="line">  * Constants for the filetype field of the mach_header</span><br><span class="line">  *&#x2F;</span><br><span class="line">#define    MH_OBJECT    0x1        &#x2F;* relocatable object file *&#x2F;</span><br><span class="line">#define    MH_EXECUTE    0x2        &#x2F;* demand paged executable file *&#x2F;</span><br><span class="line">#define    MH_FVMLIB    0x3        &#x2F;* fixed VM shared library file *&#x2F;</span><br><span class="line">#define    MH_CORE        0x4        &#x2F;* core file *&#x2F;</span><br><span class="line">#define    MH_PRELOAD    0x5        &#x2F;* preloaded executable file *&#x2F;</span><br><span class="line">#define    MH_DYLIB    0x6        &#x2F;* dynamically bound shared library *&#x2F;</span><br><span class="line">#define    MH_DYLINKER    0x7        &#x2F;* dynamic link editor *&#x2F;</span><br><span class="line">#define    MH_BUNDLE    0x8        &#x2F;* dynamically bound bundle file *&#x2F;</span><br><span class="line">#define    MH_DYLIB_STUB    0x9        &#x2F;* shared library stub for static *&#x2F;</span><br><span class="line">#define    MH_DSYM        0xa        &#x2F;* companion file with only debug *&#x2F;</span><br><span class="line">#define    MH_KEXT_BUNDLE    0xb        &#x2F;* x86_64 kexts *&#x2F;</span><br></pre></td></tr></table></figure><ul><li><code>ncmds</code> ：加载命令条数</li><li><code>sizeofcmds</code>：所有加载命令的大小</li><li><code>reserved</code>：保留字段</li><li><code>flags</code>：标志位，刚才demo中显示的都在这里了，其余的有兴趣可以阅读 <code>mach o</code> 源码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define    MH_NOUNDEFS    0x1        &#x2F;&#x2F; 目前没有未定义的符号，不存在链接依赖</span><br><span class="line">#define    MH_DYLDLINK    0x4        &#x2F;&#x2F; 该文件是dyld的输入文件，无法被再次静态链接</span><br><span class="line">#define    MH_PIE 0x200000        &#x2F;&#x2F; 加载程序在随机的地址空间，只在 MH_EXECUTE中使用</span><br><span class="line">#define    MH_TWOLEVEL    0x80    &#x2F;&#x2F; 两级名称空间</span><br></pre></td></tr></table></figure><h3 id="随机地址空间"><a href="#随机地址空间" class="headerlink" title="随机地址空间"></a>随机地址空间</h3><p>进程每一次启动，地址空间都会简单地随机化。</p><p>对于大多数应用程序来说，地址空间随机化是一个和他们完全不相关的实现细节，但是对于黑客来说，它具有重大的意义。</p><p>如果采用传统的方式，程序的每一次启动的虚拟内存镜像都是一致的，黑客很容易采取重写内存的方式来破解程序。采用ASLR可以有效的避免黑客攻击.</p><h3 id="dyld"><a href="#dyld" class="headerlink" title="dyld"></a>dyld</h3><p>动态链接器，他是苹果开源的一个项目，可以在<a href="http://opensource.apple.com/tarballs/dyld/dyld-360.18.tar.gz" target="_blank" rel="noopener">这里</a>下载，当内核执行<code>LC_DYLINK</code>（后面会说到）时，连接器会启动，查找进程所依赖的动态库，并加载到内存中。</p><h3 id="二级名称空间"><a href="#二级名称空间" class="headerlink" title="二级名称空间"></a>二级名称空间</h3><p>这是<code>dyld</code>的一个独有特性，说是符号空间中还包括所在库的信息，这样子就可以让两个不同的库导出相同的符号，与其对应的是平坦名称空间</p><h3 id="Load-commands-结构"><a href="#Load-commands-结构" class="headerlink" title="Load commands 结构"></a>Load commands 结构</h3><p><code>Load commands</code>紧跟在头部之后，这些加载指令清晰地告诉加载器如何处理二进制数据，有些命令是由内核处理的，有些是由动态链接器处理的。在源码中有明显的注释来说明这些是动态连接器处理的。</p><p>例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 将文件的32位或64位的段映射到进程地址空间</span><br><span class="line">#define    LC_SEGMENT    0x1    </span><br><span class="line">#define    LC_SEGMENT_64    0x19    </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 唯一的 UUID，标示二进制文件</span><br><span class="line">#define    LC_UUID        0x1b    &#x2F;* the uuid *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 刚才提到的，启动动态加载连接器</span><br><span class="line">#define    LC_LOAD_DYLINKER 0xe    &#x2F;* load a dynamic linker *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 代码签名和加密</span><br><span class="line">#define    LC_CODE_SIGNATURE 0x1d    &#x2F;* local of code signature *&#x2F;</span><br><span class="line">#define    LC_ENCRYPTION_INFO 0x21    &#x2F;* encrypted segment information *&#x2F;</span><br></pre></td></tr></table></figure><p><code>load command</code>的结构如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct load_command &#123;</span><br><span class="line">    uint32_t cmd;        &#x2F;* type of load command *&#x2F;</span><br><span class="line">    uint32_t cmdsize;    &#x2F;* total size of command in bytes *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过 <code>MachOView</code>来继续查看刚才Demo中的<code>Load commands</code>的一些细节，<code>LC_SEGMENT_64</code>和<code>LC_SEGMENT</code>是加载的主要命令，它负责指导内核来设置进程的内存空间</p><p><img src="/img/mach-oLoadCommand.png" alt=""></p><ul><li><code>cmd</code>：就是<code>Load commands</code>的类型，这里<code>LC_SEGMENT_64</code>代表将文件中64位的段映射到进程的地址空间。<code>LC_SEGMENT_64</code>和<code>LC_SEGMENT</code>的结构差别不大,简单举例:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct segment_command_64 &#123; &#x2F;* for 64-bit architectures *&#x2F;</span><br><span class="line">    uint32_t    cmd;        &#x2F;* LC_SEGMENT_64 *&#x2F;</span><br><span class="line">    uint32_t    cmdsize;    &#x2F;* includes sizeof section_64 structs *&#x2F;</span><br><span class="line">    char        segname[16];    &#x2F;* segment name *&#x2F;</span><br><span class="line">    uint64_t    vmaddr;        &#x2F;* memory address of this segment *&#x2F;</span><br><span class="line">    uint64_t    vmsize;        &#x2F;* memory size of this segment *&#x2F;</span><br><span class="line">    uint64_t    fileoff;    &#x2F;* file offset of this segment *&#x2F;</span><br><span class="line">    uint64_t    filesize;    &#x2F;* amount to map from the file *&#x2F;</span><br><span class="line">    vm_prot_t    maxprot;    &#x2F;* maximum VM protection *&#x2F;</span><br><span class="line">    vm_prot_t    initprot;    &#x2F;* initial VM protection *&#x2F;</span><br><span class="line">    uint32_t    nsects;        &#x2F;* number of sections in segment *&#x2F;</span><br><span class="line">    uint32_t    flags;        &#x2F;* flags *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>cmdsize</code>：代表<code>load command</code>的大小</li><li><code>VM Address</code> ：段的虚拟内存地址</li><li><code>VM Size</code> ： 段的虚拟内存大小</li><li><code>file offset</code>：段在文件中偏移量</li><li><code>file size</code>：段在文件中的大小</li></ul><p>将该段对应的文件内容加载到内存中：从<code>offset</code>处加载 <code>file size</code>大小到虚拟内存 <code>vmaddr</code>处，由于这里在内存地址空间中是<code>_PAGEZERO</code>段（这个段不具有访问权限，用来处理空指针）所以都是零</p><p>还有图片中的其他段，比如<code>_TEXT</code>对应的就是代码段，<code>_DATA</code>对应的是可读／可写的数据，<code>_LINKEDIT</code>是支持<code>dyld</code>的，里面包含一些符号表等数据</p><ul><li><code>nsects</code>：标示了<code>Segment</code>中有多少<code>secetion</code></li><li><code>segment name</code>：段的名称，当前是<code>__PAGEZERO</code></li></ul><h3 id="Segment-amp-Section"><a href="#Segment-amp-Section" class="headerlink" title="Segment &amp; Section"></a>Segment &amp; Section</h3><p>这里有个命名的问题，如下图所示，<code>__TEXT</code>代表的是<code>Segment</code>，小写的<code>__text</code>代表 <code>Section</code></p><p>/<img src="/img/mach-oSection.png" alt=""></p><p><code>Section</code>的数据结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct section &#123; &#x2F;* for 32-bit architectures *&#x2F;</span><br><span class="line">    char        sectname[16];    &#x2F;* name of this section *&#x2F;</span><br><span class="line">    char        segname[16];    &#x2F;* segment this section goes in *&#x2F;</span><br><span class="line">    uint32_t    addr;        &#x2F;* memory address of this section *&#x2F;</span><br><span class="line">    uint32_t    size;        &#x2F;* size in bytes of this section *&#x2F;</span><br><span class="line">    uint32_t    offset;        &#x2F;* file offset of this section *&#x2F;</span><br><span class="line">    uint32_t    align;        &#x2F;* section alignment (power of 2) *&#x2F;</span><br><span class="line">    uint32_t    reloff;        &#x2F;* file offset of relocation entries *&#x2F;</span><br><span class="line">    uint32_t    nreloc;        &#x2F;* number of relocation entries *&#x2F;</span><br><span class="line">    uint32_t    flags;        &#x2F;* flags (section type and attributes)*&#x2F;</span><br><span class="line">    uint32_t    reserved1;    &#x2F;* reserved (for offset or index) *&#x2F;</span><br><span class="line">    uint32_t    reserved2;    &#x2F;* reserved (for count or sizeof) *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>sectname</code>：比如<code>_text</code>、<code>stubs</code></li><li><code>segname</code> ：该<code>section</code>所属的<code>segment</code>，比如<code>__TEXT</code></li><li><code>addr</code> ： 该<code>section</code>在内存的起始位置</li><li><code>size</code>： 该<code>section</code>的大小</li><li><code>offset</code>： 该<code>section</code>的文件偏移</li><li><code>align</code> ：字节大小对齐</li><li><code>reloff</code> ：重定位入口的文件偏移</li><li><code>nreloc</code>： 需要重定位的入口数量</li><li><code>flags</code>：包含<code>section</code>的<code>type</code>和<code>attributes</code></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;不同操作系统的k而执行文件格式都不相同,例如:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Linux&lt;/code&gt;下可执行文件的格式 –&amp;gt; &lt;code&gt;ELF&lt;/code&gt;&lt;br&gt;&lt;code&gt;windows&lt;/code&gt;的可执行文件的格式 –&amp;gt; &lt;code&gt;PE32／PE32+&lt;/code&gt;&lt;br&gt;&lt;code&gt;OS X和iOS&lt;/code&gt;的可执行文件的格式 –&amp;gt; &lt;code&gt;Mach-O&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>逆向之手机app砸壳记录</title>
    <link href="http://zxn.wiki/2017/04/02/%E9%80%86%E5%90%91%E4%B9%8B%E6%89%8B%E6%9C%BAapp%E7%A0%B8%E5%A3%B3%E8%AE%B0%E5%BD%95/"/>
    <id>http://zxn.wiki/2017/04/02/%E9%80%86%E5%90%91%E4%B9%8B%E6%89%8B%E6%9C%BAapp%E7%A0%B8%E5%A3%B3%E8%AE%B0%E5%BD%95/</id>
    <published>2017-04-02T13:38:44.000Z</published>
    <updated>2021-06-25T02:55:08.397Z</updated>
    
    <content type="html"><![CDATA[<p>之前做手机逆向把手机给越狱了,过了一些时间了,整理下砸壳手机app的过程.</p><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><ul><li>越狱手机</li><li>dumpdecrypted</li><li>安装越狱插件: openssh</li><li>插件 adv-cmds</li><li>插件 cycript</li></ul><p>&lt;Excerpt in index | 首页摘要&gt;<br> <a id="more"></a><br>&lt;The rest of contents | 余下全文&gt;</p><p>注: 这里只是根据本次砸壳经历记录过程,详情请参考<a href="http://www.swiftyper.com/2016/05/02/iOS-reverse-step-by-step-part-1-class-dump/" target="_blank" rel="noopener">iOS 逆向手把手教程</a></p><p>为了砸壳，我们需要使用到 <code>dumpdecrypted</code>，这个工具已经开源并且托管在了 GitHub 上面，我们需要进行手动编译。步骤如下：<br>1 . 从 GitHub 上 clone 源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;iOSReverse</span><br><span class="line">git clone git:&#x2F;&#x2F;github.com&#x2F;stefanesser&#x2F;dumpdecrypted&#x2F;</span><br></pre></td></tr></table></figure><p>2 . 编译 <code>dumpdecrypted.dylib</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd dumpdecrypted&#x2F;</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>执行完 make 命令之后，在当前目录下就会生成一个 dumpdecrypted.dylib，这个就是我们等下要使用到的砸壳工具.</p><h3 id="ssh链接"><a href="#ssh链接" class="headerlink" title="ssh链接"></a>ssh链接</h3><p>使用 ssh 连上你的 iOS 系统</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh root@192.168.2.142</span><br></pre></td></tr></table></figure><h3 id="查找微信的可执行文件"><a href="#查找微信的可执行文件" class="headerlink" title="查找微信的可执行文件"></a>查找微信的可执行文件</h3><p>手机连上之后，使用 ps 配合 grep 命令来找到微信的可执行文件: ps 插件 —&gt; adv-cmds</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -e | grep WeChat</span><br><span class="line">得到路径 :</span><br><span class="line">&#x2F;var&#x2F;mobile&#x2F;Containers&#x2F;Bundle&#x2F;Application&#x2F;5B0950A5-9F44-4EF5-AAA6-FF994DD6EC1D&#x2F;WeChat.app&#x2F;WeChat</span><br></pre></td></tr></table></figure><h3 id="查找Documents-目录路径"><a href="#查找Documents-目录路径" class="headerlink" title="查找Documents 目录路径"></a>查找Documents 目录路径</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cycript -p WeChat</span><br><span class="line">得到路径 :</span><br><span class="line">&#x2F;var&#x2F;mobile&#x2F;Containers&#x2F;Data&#x2F;Application&#x2F;ADC7EF50-3AD6-43FE-89D5-61308163C34B</span><br></pre></td></tr></table></figure><p>可以看到，我们打印出了应用的 Home 目录，而 Documents 目录就是在 Home 的下一层，所以在我这里 Documents 的全路径就为 <code>/var/mobile/Containers/Data/Application/ADC7EF50-3AD6-43FE-89D5-61308163C34B/Documents</code></p><h3 id="开始砸壳"><a href="#开始砸壳" class="headerlink" title="开始砸壳"></a>开始砸壳</h3><p>将 <code>dumpdecrypted.dylib</code> 拷到 <code>Documents</code> 目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scp ~&#x2F;iOSReverse&#x2F;dumpdecrypted&#x2F;dumpdecrypted.dylib root@192.168.2.142:&#x2F;var&#x2F;mobile&#x2F;Containers&#x2F;Data&#x2F;Application&#x2F;ADC7EF50-3AD6-43FE-89D5-61308163C34B&#x2F;Documents</span><br></pre></td></tr></table></figure><p>接下来进行真正的砸壳步骤:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd  &#x2F;var&#x2F;mobile&#x2F;Containers&#x2F;Data&#x2F;Application&#x2F;ADC7EF50-3AD6-43FE-89D5-61308163C34B&#x2F;Documents</span><br><span class="line"># 后面的路径即为一开始使用 ps 命令找到的目标应用可执行文件的路径</span><br><span class="line">$ DYLD_INSERT_LIBRARIES&#x3D;dumpdecrypted.dylib &#x2F;var&#x2F;mobile&#x2F;Containers&#x2F;Bundle&#x2F;Application&#x2F;5B0950A5-9F44-4EF5-AAA6-FF994DD6EC1D&#x2F;WeChat.app&#x2F;WeChat</span><br></pre></td></tr></table></figure><p>完成后 <code>ls</code> 会在当前目录生成一个 WeChat.decrypted 文件，这就是砸壳后的文件</p><h3 id="读取砸壳后文件"><a href="#读取砸壳后文件" class="headerlink" title="读取砸壳后文件"></a>读取砸壳后文件</h3><p>从手机中读取文件到电脑 (必须在mac命令行 不是ssh的手机命令行) :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp root@192.168.2.142:&#x2F;var&#x2F;mobile&#x2F;Containers&#x2F;Data&#x2F;Application&#x2F;ADC7EF50-3AD6-43FE-89D5-61308163C34B&#x2F;Documents&#x2F;WeChat.decrypted ~&#x2F;iOSReverse</span><br></pre></td></tr></table></figure><h3 id="获取头文件"><a href="#获取头文件" class="headerlink" title="获取头文件"></a>获取头文件</h3><p>class-dump 针对架构( <strong>–arch armv7</strong> )导出头文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class-dump --arch armv7 -H WeChat.decrypted -o outHeader</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前做手机逆向把手机给越狱了,过了一些时间了,整理下砸壳手机app的过程.&lt;/p&gt;
&lt;h3 id=&quot;前提条件&quot;&gt;&lt;a href=&quot;#前提条件&quot; class=&quot;headerlink&quot; title=&quot;前提条件&quot;&gt;&lt;/a&gt;前提条件&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;越狱手机&lt;/li&gt;
&lt;li&gt;dumpdecrypted&lt;/li&gt;
&lt;li&gt;安装越狱插件: openssh&lt;/li&gt;
&lt;li&gt;插件 adv-cmds&lt;/li&gt;
&lt;li&gt;插件 cycript&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>iOS动画总结</title>
    <link href="http://zxn.wiki/2016/09/03/iOS%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93/"/>
    <id>http://zxn.wiki/2016/09/03/iOS%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93/</id>
    <published>2016-09-03T12:41:00.000Z</published>
    <updated>2021-06-25T02:55:08.396Z</updated>
    
    <content type="html"><![CDATA[<p>iOS 动画总结:</p><h3 id="UIView-动画"><a href="#UIView-动画" class="headerlink" title="UIView 动画"></a>UIView 动画</h3><p>比较简单的一种:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ animateWithDuration:animations:</span><br></pre></td></tr></table></figure><p>&lt;Excerpt in index | 首页摘要&gt;<br> <a id="more"></a><br>&lt;The rest of contents | 余下全文&gt;</p><p>第一个参数是动画的持续时间，第二个参数是一个 block，在 animations block 中对 UIView 的属性进行调整，设置 UIView 动画结束后最终的效果，iOS 就会自动补充中间帧，形成动画</p><p>可以更改的属性有:</p><ul><li>frame</li><li>bounds</li><li>center</li><li>transform</li><li>alpha</li><li>backgroundColor</li><li>contentStretch</li></ul><p>这些属性大都是 View 的基本属性,其中有一个比较特殊的 transform 属性，它的类型是 CGAffineTransform，即 2D 仿射变换，这是个数学中的概念，用一个三维矩阵来表述 2D 图形的矢量变换。用 transform 属性对 View 进行：</p><ul><li>旋转</li><li>缩放</li><li>其他自定义 2D 变换</li></ul><p>iOS 提供了下面的函数可以创建简单的 2D 变换：</p><ul><li>CGAffineTransformMakeScale</li><li>CGAffineTransformMakeRotation</li><li>CGAffineTransformMakeTranslation</li></ul><p>将 View 缩小至原来的 1/4 大小,代码示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[UIView animateWithDuration:2.0 animations:^&#123;</span><br><span class="line">    myView.transform &#x3D; CGAffineTransformMakeScale(0.5, 0.5);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="调节参数"><a href="#调节参数" class="headerlink" title="调节参数"></a>调节参数</h3><p>完整版的 animate 函数其实是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ animateWithDuration:delay:options:animations:completion:</span><br></pre></td></tr></table></figure><p>可以通过 delay 参数调节让动画延迟产生，同时还一个 options 选项可以调节动画进行的方式。可用的 options 可分为两类：<br> <strong>控制过程</strong> 和 <strong>控制速度</strong></p><p><strong>控制过程</strong><br>例如 <code>UIViewAnimationOptionRepeat</code> 可以让动画反复进行， <code>UIViewAnimationOptionAllowUserInteraction</code> 可以让允许用户对动画进行过程中同 View 进行交互（默认是不允许的）</p><p><strong>控制速度</strong><br>动画的进行速度可以用速度曲线来表示,提供的选项例如 <code>UIViewAnimationOptionCurveEaseIn</code> 是先慢后快，<code>UIViewAnimationOptionCurveEaseOut</code> 是先快后慢。</p><p>不同的选项直接可以通过“与”操作进行合并，同时使用，例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIViewAnimationOptionRepeat | UIViewAnimationOptionAllowUserInteraction</span><br></pre></td></tr></table></figure><h3 id="关键帧动画"><a href="#关键帧动画" class="headerlink" title="关键帧动画"></a>关键帧动画</h3><p>上面介绍的动画中，我们只能控制开始和结束时的效果，然后由系统补全中间的过程，有些时候我们需要自己设定若干关键帧，实现更复杂的动画效果，这时候就需要关键帧动画的支持了,示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[UIView animateKeyframesWithDuration:2.0 delay:0.0 options:UIViewKeyframeAnimationOptionRepeat | UIViewKeyframeAnimationOptionAutoreverse animations:^&#123;</span><br><span class="line">    [UIView addKeyframeWithRelativeStartTime:0.0 relativeDuration:0.5 animations:^&#123;</span><br><span class="line">        self.myView.frame &#x3D; CGRectMake(10, 50, 100, 100);</span><br><span class="line">    &#125;];</span><br><span class="line">    [UIView addKeyframeWithRelativeStartTime: 0.5 relativeDuration:0.3 animations:^&#123;</span><br><span class="line">        self.myView.frame &#x3D; CGRectMake(20, 100, 100, 100);</span><br><span class="line">    &#125;];</span><br><span class="line">    [UIView addKeyframeWithRelativeStartTime:0.8 relativeDuration:0.2 animations:^&#123;</span><br><span class="line">        self.myView.transform &#x3D; CGAffineTransformMakeScale(0.5, 0.5);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125; completion:nil];</span><br></pre></td></tr></table></figure><p>这个例子添加了三个关键帧，在外面的 <code>animateKeyframesWithDuration</code> 中我们设置了持续时间为 <code>2.0</code> 秒，这是真实意义上的时间，里面的 <code>startTime</code> 和 <code>relativeDuration</code> 都是相对时间。以第一个为例，<code>startTime</code> 为 <code>0.</code>0，<code>relativeTime</code> 为 <code>0.5</code>，这个动画会直接开始，持续时间为 <code>2.0 X 0.5 = 1.0</code> 秒，下面第二个的开始时间是 <code>0.5</code>，正好承接上一个结束，第三个同理，这样三个动画就变成连续的动画了。</p><h3 id="View-的转换"><a href="#View-的转换" class="headerlink" title="View 的转换"></a>View 的转换</h3><p>iOS 还提供了两个函数，用于进行两个 View 之间通过动画换场：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ transitionWithView:duration:options:animations:completion:</span><br><span class="line">+ transitionFromView:toView:duration:options:completion:</span><br></pre></td></tr></table></figure><p>需要注意的是，换场动画会在这两个 View 共同的父 View 上进行，在写动画之前，先要设计好 View 的继承结构。</p><p>同样，View 之间的转换也有很多选项可选，例如 <code>UIViewAnimationOptionTransitionFlipFromLeft</code> 从左边翻转，<code>UIViewAnimationOptionTransitionCrossDissolve</code> 渐变等等。</p><h3 id="CALayer-Animation"><a href="#CALayer-Animation" class="headerlink" title="CALayer Animation"></a>CALayer Animation</h3><p>UIView 的动画简单易用，但是能实现的效果相对有限，上面介绍的 UIView 的几种动画方式，实际上是对底层 CALayer 动画的一种封装。直接使用 CALayer 层的动画方法可以实现更多高级的动画效果。</p><p>引入 <strong>QuartzCore.framework</strong></p><ul><li>基本动画（CABasicAnimation）</li></ul><p>CABasicAnimation 用于创建一个 CALayer 上的基本动画效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CABasicAnimation *animation &#x3D; [CABasicAnimation animationWithKeyPath:@&quot;position.x&quot;];</span><br><span class="line">animation.toValue &#x3D; @200;</span><br><span class="line">animation.duration &#x3D; 0.8;</span><br><span class="line">animation.repeatCount &#x3D; 5;</span><br><span class="line">animation.beginTime &#x3D; CACurrentMediaTime() + 0.5;</span><br><span class="line">animation.fillMode &#x3D; kCAFillModeRemoved;</span><br><span class="line">[self.myView.layer addAnimation:animation forKey:nil];</span><br></pre></td></tr></table></figure><p><strong>KeyPath:</strong><br>这里我们使用了 animationWithKeyPath 这个方法来改变 layer 的属性，可以使用的属性有很多，具体可以参考<a href="http://www.cnblogs.com/pengyingh/articles/2379631.html" target="_blank" rel="noopener">这里</a>。其中很多属性在前面介绍的 UIView 动画部分我们也看到过，进一步验证了 UIView 的动画方法是对底层 CALayer 的一种封装。</p><p>需要注意的一点是，上面我们使用了 <code>position</code> 属性， layer 的这个 <code>position</code> 属性和 <code>View</code> 的 frame 以及 bounds 属性都不相同，而是和 Layer 的 <code>anchorPoint</code> 有关，可以由下面的公式计算得到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">position.x &#x3D; frame.origin.x + 0.5 * bounds.size.width；  </span><br><span class="line">position.y &#x3D; frame.origin.y + 0.5 * bounds.size.height；</span><br></pre></td></tr></table></figure><p><strong>属性:</strong></p><p>CABasicAnimation 的属性有下面几个：</p><ul><li>beginTime</li><li>duration</li><li>fromValue</li><li>toValue</li><li>byValue</li><li>repeatCount</li><li>autoreverses</li><li>timingFunction</li></ul><p>可以看到，其中 beginTime，duration，repeatCount 等属性和上面在 UIView 中使用到的 duration，UIViewAnimationOptionRepeat 等选项是相对应的，不过这里的选项能够提供更多的扩展性。</p><p>需要注意的是 <code>fromValue</code>，<code>toValue</code>，<code>byValue</code> 这几个选项，支持的设置模式有下面几种：</p><ul><li>设置 fromValue 和 toValue：从 fromValue 变化到 toValue</li><li>设置 fromValue 和 byValue：从 fromValue 变化到 fromValue + byValue</li><li>设置 byValue 和 toValue：从 toValue - byValue 变化到 toValue</li><li>设置 fromValue： 从 fromValue 变化到属性当前值</li><li>设置 toValue：从属性当前值变化到 toValue</li><li>设置 byValue：从属性当前值变化到属性当前值 + toValue</li></ul><p>看起来挺复杂，其实概括起来基本就是，如果某个值不设置，就是用这个属性当前的值</p><p>另外，可以看到上面我们使用的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animation.toValue &#x3D; @200;</span><br></pre></td></tr></table></figure><p>而不是直接使用 200，因为 <code>toValue</code> 之类的属性为 <code>id</code> 类型，或者像这样使用 @ 符号，或者使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animation.toValue &#x3D; [NSNumber numberWithInt:200];</span><br></pre></td></tr></table></figure><p>最后一个比较有意思的是 <code>timingFunction</code> 属性，使用这个属性可以自定义动画的运动曲线（节奏，pacing），系统提供了五种值可以选择：</p><ul><li>kCAMediaTimingFunctionLinear 线性动画</li><li>kCAMediaTimingFunctionEaseIn 先快后慢</li><li>kCAMediaTimingFunctionEaseOut 先慢后快</li><li>kCAMediaTimingFunctionEaseInEaseOut 先慢后快再慢</li><li>kCAMediaTimingFunctionDefault 默认，也属于中间比较快</li></ul><h3 id="关键帧动画（CAKeyframeAnimation）"><a href="#关键帧动画（CAKeyframeAnimation）" class="headerlink" title="关键帧动画（CAKeyframeAnimation）"></a>关键帧动画（CAKeyframeAnimation）</h3><p>同 UIView 中的类似，CALayer 层也提供了关键帧动画的支持，<code>CAKeyFrameAnimation</code> 和 <code>CABasicAnimation</code> 都继承自 <code>CAPropertyAnimation</code>，因此它有具有上面提到的那些属性，此外，<code>CAKeyFrameAnimation</code> 还有特有的几个属性。</p><p><strong>values 和 keyTimes</strong></p><p>使用 <code>values</code> 和 <code>keyTimes</code> 可以共同确定一个动画的若干关键帧,示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CAKeyframeAnimation *anima &#x3D; [CAKeyframeAnimation animationWithKeyPath:@&quot;transform.rotation&quot;];&#x2F;&#x2F;在这里@&quot;transform.rotation&quot;&#x3D;&#x3D;@&quot;transform.rotation.z&quot;</span><br><span class="line">NSValue *value1 &#x3D; [NSNumber numberWithFloat:-M_PI&#x2F;180*4];</span><br><span class="line">NSValue *value2 &#x3D; [NSNumber numberWithFloat:M_PI&#x2F;180*4];</span><br><span class="line">NSValue *value3 &#x3D; [NSNumber numberWithFloat:-M_PI&#x2F;180*4];</span><br><span class="line">anima.values &#x3D; @[value1,value2,value3];</span><br><span class="line">&#x2F;&#x2F; anima.keyTimes &#x3D; @[@0.0, @0.5, @1.0];</span><br><span class="line">anima.repeatCount &#x3D; MAXFLOAT;</span><br><span class="line">[_demoView.layer addAnimation:anima forKey:@&quot;shakeAnimation&quot;];</span><br></pre></td></tr></table></figure><p>可以看到上面这个动画共有三个关键帧，如果没有指定 keyTimes 则各个关键帧会平分整个动画的时间(duration)。</p><p><strong>path</strong><br>使用 path 属性可以设置一个动画的运动路径，注意 path 只对 CALayer 的 anchorPoint 和position 属性起作用，另外如果你设置了 path ，那么 values 将被忽略.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CAKeyframeAnimation *anima &#x3D; [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];</span><br><span class="line">UIBezierPath *path &#x3D; [UIBezierPath bezierPathWithOvalInRect:CGRectMake(SCREEN_WIDTH&#x2F;2-100, SCREEN_HEIGHT&#x2F;2-100, 200, 200)];</span><br><span class="line">anima.path &#x3D; path.CGPath;</span><br><span class="line">anima.duration &#x3D; 2.0f;</span><br><span class="line">[_demoView.layer addAnimation:anima forKey:@&quot;pathAnimation&quot;];</span><br></pre></td></tr></table></figure><p><strong>组动画（CAAnimationGroup)</strong></p><p>组动画可以将一组动画组合在一起，所有动画对象可以同时运行，示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CAAnimationGroup *group &#x3D; [[CAAnimationGroup alloc] init];</span><br><span class="line">CABasicAnimation *animationOne &#x3D; [CABasicAnimation animationWithKeyPath:@&quot;transform.scale&quot;];</span><br><span class="line"></span><br><span class="line">animationOne.toValue &#x3D; @2.0;</span><br><span class="line">animationOne.duration &#x3D; 1.0;</span><br><span class="line"></span><br><span class="line">CABasicAnimation *animationTwo &#x3D; [CABasicAnimation animationWithKeyPath:@&quot;position.x&quot;];</span><br><span class="line">animationTwo.toValue &#x3D; @400;</span><br><span class="line">animationTwo.duration &#x3D; 1.0;</span><br><span class="line"></span><br><span class="line">[group setAnimations:@[animationOne, animationTwo]];</span><br><span class="line">[self.myView.layer addAnimation:group forKey:nil];</span><br></pre></td></tr></table></figure><p>需要注意的是，一个 group 组内的某个动画的持续时间（duration），如果超过了整个组的动画持续时间，那么多出的动画时间将不会被展示。例如一个 group 的持续时间是 5s，而组内一个动画持续时间为 10s ，那么这个 10s 的动画只会展示前 5s 。</p><p><strong>切换动画（CATransition）</strong><br>CATransition 可以用于 View 或 ViewController 直接的换场动画：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">self.myView.backgroundColor &#x3D; [UIColor blueColor];</span><br><span class="line">CATransition *trans &#x3D; [CATransition animation];</span><br><span class="line">trans.duration &#x3D; 1.0;</span><br><span class="line">trans.type &#x3D; @&quot;push&quot;;</span><br><span class="line"></span><br><span class="line">[self.myView.layer addAnimation:trans forKey:nil];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这句放在下面也可以</span><br><span class="line">&#x2F;&#x2F; self.myView.backgroundColor &#x3D; [UIColor blueColor];</span><br></pre></td></tr></table></figure><h3 id="更高级的动画效果"><a href="#更高级的动画效果" class="headerlink" title="更高级的动画效果"></a>更高级的动画效果</h3><p>详情会在另一篇文章中汇总<br><strong>CADisplayLink</strong><br>CADisplayLink 是一个计时器对象，可以周期性的调用某个 selecor 方法。相比 NSTimer ，它可以让我们以和屏幕刷新率同步的频率（每秒60次）来调用绘制函数，实现界面连续的不停重绘，从而实现动画效果。</p><p><strong>UIDynamicAnimator</strong><br>UIDynamicAnimator 是 iOS 7 引入的一个新类，可以创建出具有物理仿真效果的动画，具体提供了下面几种物理仿真行为：</p><ul><li>UIGravityBehavior：重力行为</li><li>UICollisionBehavior：碰撞行为</li><li>UISnapBehavior：捕捉行为</li><li>UIPushBehavior：推动行为</li><li>UIAttachmentBehavior：附着行为</li><li>UIDynamicItemBehavior：动力元素行为</li></ul><p><strong>CAEmitterLayer</strong><br>CAEmitterLayer 是 Core Animation 提供的一个粒子发生器系统，可以用于创建各种粒子动画，例如烟雾，焰火等效果。</p><p>参考:<a href="https://hit-alibaba.github.io/interview/iOS/Cocoa-Touch/Animation.html" target="_blank" rel="noopener">这里</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;iOS 动画总结:&lt;/p&gt;
&lt;h3 id=&quot;UIView-动画&quot;&gt;&lt;a href=&quot;#UIView-动画&quot; class=&quot;headerlink&quot; title=&quot;UIView 动画&quot;&gt;&lt;/a&gt;UIView 动画&lt;/h3&gt;&lt;p&gt;比较简单的一种:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ animateWithDuration:animations:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>UIApplicaion解析</title>
    <link href="http://zxn.wiki/2016/08/09/UIApplicaion%E8%A7%A3%E6%9E%90/"/>
    <id>http://zxn.wiki/2016/08/09/UIApplicaion%E8%A7%A3%E6%9E%90/</id>
    <published>2016-08-09T12:31:18.000Z</published>
    <updated>2021-06-25T02:55:08.396Z</updated>
    
    <content type="html"><![CDATA[<p>UIApplicaion 的简介:<br>UIApplication 的核心作用是提供了 iOS 程序运行期间的控制和协作工作</p><p>每一个程序在运行期必须有且仅有一个 UIApplication（或则其子类）的一个实例。</p><p><code>UIApplicationMain</code> 函数是程序进入点，并且UIApplication 是一个单例实例。</p><p>你可以通过调用 <code>[UIApplication sharedApplication]</code> 来得到这个单例实例的指针。</p><p>&lt;Excerpt in index | 首页摘要&gt;<br> <a id="more"></a><br>&lt;The rest of contents | 余下全文&gt;</p><p>UIApplication 的一个主要工作是处理用户事件，它会起一个队列，把所有用户事件都放入队列，逐个处理，在处理的时候，它会发送当前事件 到一个合适的处理事件的目标控件。此外，UIApplication 实例还维护一个在本应用中打开的 window 列表（UIWindow 实例），这样它就 可以接触应用中的任何一个 UIView 对象。UIApplication 实例会被赋予一个代理对象，以处理应用程序的生命周期事件（比如程序启动和关闭）、系统事件（比如来电、记事项警告）等等。</p><h3 id="UIApplicaion-生命周期"><a href="#UIApplicaion-生命周期" class="headerlink" title="UIApplicaion 生命周期"></a>UIApplicaion 生命周期</h3><p>一个 UIApplication 可以有如下几种状态：</p><ul><li>Not running – &gt; 程序没启动</li><li>Inactive – &gt; 程序在前台运行，不过没有接收到事件</li><li>Active – &gt; 程序在前台运行而且接收到了事件。这也是前台的一个正常的模式</li><li>Background – &gt; 程序在后台而且能执行代码，大多数程序进入这个状态后会在在这个状态上停留一会。时间到之后会进入挂起状态 (Suspended)。有的程序经过特殊的请求后可以长期处于 Background 状态</li><li>Suspended – &gt; 程序在后台不能执行代码。系统会自动把程序变成这个状态而且不会发出通知。当挂起时，程序还是停留在内存中的，当系统内存低时，系统就把挂起的程序清除掉，为前台程序提供更多的内存。</li></ul><h3 id="常使用的代理"><a href="#常使用的代理" class="headerlink" title="常使用的代理:"></a>常使用的代理:</h3><p>当应用程序将要入非活动状态执行，在此期间，应用程序不接收消息或事件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)applicationWillResignActive:(UIApplication *)application</span><br></pre></td></tr></table></figure><p>当应用程序入活动状态执行，这个刚好跟上面那个方法相反:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)applicationDidBecomeActive:(UIApplication *)application</span><br></pre></td></tr></table></figure><p>当程序被推送到后台的时候调用。所以要设置后台继续运行，则在这个函数里面设置即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)applicationDidEnterBackground:(UIApplication *)application</span><br></pre></td></tr></table></figure><p>当程序从后台将要重新回到前台时候调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)applicationWillEnterForeground:(UIApplication *)application</span><br></pre></td></tr></table></figure><p>当程序将要退出时被调用，通常是用来保存数据和一些退出前的清理工作。这个需要设置 UIApplicationExitsOnSuspend 的键值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)applicationWillTerminate:(UIApplication *)application</span><br></pre></td></tr></table></figure><p>iPhone 设备只有有限的内存，如果为应用程序分配了太多内存操作系统会终止应用程序的运行，在终止前会执行这个方法，通常可以在这里进行内存清理工作防止程序被终止</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)applicationDidReceiveMemoryWarning:(UIApplication *)application</span><br></pre></td></tr></table></figure><p>当系统时间发生改变时执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)applicationSignificantTimeChange:(UIApplication*)application</span><br></pre></td></tr></table></figure><p>当程序载入后执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)applicationDidFinishLaunching:(UIApplication*)application</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;UIApplicaion 的简介:&lt;br&gt;UIApplication 的核心作用是提供了 iOS 程序运行期间的控制和协作工作&lt;/p&gt;
&lt;p&gt;每一个程序在运行期必须有且仅有一个 UIApplication（或则其子类）的一个实例。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;UIApplicationMain&lt;/code&gt; 函数是程序进入点，并且UIApplication 是一个单例实例。&lt;/p&gt;
&lt;p&gt;你可以通过调用 &lt;code&gt;[UIApplication sharedApplication]&lt;/code&gt; 来得到这个单例实例的指针。&lt;/p&gt;
&lt;p&gt;&amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Runtime消息转发</title>
    <link href="http://zxn.wiki/2016/07/26/Runtime%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91/"/>
    <id>http://zxn.wiki/2016/07/26/Runtime%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91/</id>
    <published>2016-07-26T12:03:22.000Z</published>
    <updated>2021-06-25T02:55:08.395Z</updated>
    
    <content type="html"><![CDATA[<p>对于运行时的简单剖析,查看上一篇即可,这里查看runtime消息的转发机制</p><h3 id="方法调用流程"><a href="#方法调用流程" class="headerlink" title="方法调用流程"></a>方法调用流程</h3><p>在Objective-C中，消息直到运行时才绑定到方法实现上。编译器会将消息表达式[receiver message]转化为一个消息函数的调用，即objc_msgSend。这个函数将消息接收者和方法名作为其基础参数，如以下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(receiver, selector)</span><br></pre></td></tr></table></figure><p>&lt;Excerpt in index | 首页摘要&gt;<br> <a id="more"></a><br>&lt;The rest of contents | 余下全文&gt;</p><p>如果消息中还有其它参数，则该方法的形式如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(receiver, selector, arg1, arg2,...)</span><br></pre></td></tr></table></figure><p>这个函数完成了动态绑定的所有事情：</p><p>a、首先它找到selector对应的方法实现。因为同一个方法可<br>能在不同的类中有不同的实现，所以我们需要依赖于接收者的类<br>来找到的确切的实现。<br>b、调用方法实现，并将接收者对象及方法的所有参数传给它。<br>c、最后，它将实现返回的值作为它自己的返回值。</p><p>消息的关键在于我们前面章节讨论过的结构体objc_class，这个结构体有两个字段是我们在分发消息的关注的：<br>-&gt; 指向父类的指针<br>-&gt; 个类的方法分发表，即methodLists。<br>当我们创建一个新对象时，先为其分配内存，并初始化其成员变量。其中isa指针也会被初始化，让对象可以访问类及类的继承体系</p><p>当消息发送给一个对象时首先从运行时系统缓存使用过的方法中寻找。<br>如果找到，执行该方法,如未找到继续执行下面的步骤</p><p>objc_msgSend通过对象的isa指针获取到类的结构体，然后在方法分发表里面查找方法的selector。<br>如果没有找到selector，objc_msgSend结构体中的指向父类的指针找到其父类，并在父类的分发表里面查找方法的selector。<br>依此，会一直沿着类的继承体系到达NSObject类。一旦定位到selector，函数会就获取到了实现的入口点，并传入相应的参数来执行方法的具体实现,并将该方法添加进入缓存中如果最后没有定位到selector，则会走消息转发流程</p><h3 id="消息转发流程"><a href="#消息转发流程" class="headerlink" title="消息转发流程"></a>消息转发流程</h3><p>当一个对象能接收一个消息时，就会走正常的方法调用流程。但如果一个对象无法接收指定消息时，又会发生什么事呢？默认情况下，如果是以[object message]的方式调用方法，如果object无法响应message消息时，编译器会报错。但如果是以perform…的形式来调用，则需要等到运行时才能确定object是否能接收message消息。如果不能，则程序崩溃。</p><p>通常，当我们不能确定一个对象是否能接收某个消息时，会先调用respondsToSelector:来判断一下。如下代码所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if([self respondsToSelector:@selector(method)])&#123;</span><br><span class="line">      [self performSelector:@selector(method)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，我们这边想讨论下不使用respondsToSelector:判断的情况</p><p>当一个对象无法接收某一消息时，就会启动所谓“消息转发(message forwarding)”机制，通过这一机制，我们可以告诉对象如何处理未知的消息。默认情况下，对象接收到未知的消息，会导致程序崩溃.<br>错误由 NSObject的“doesNotRecognizeSelector”方法抛出,不过，我们可以采取一些措施，让我们的程序执行特定的逻辑，而避免程序的崩溃。</p><p>消息转发机制基本上分为三个步骤：</p><p>1&gt;、动态方法解析<br>2&gt;、备用接收者<br>3&gt;、完整转发</p><ul><li>动态方法解析</li></ul><p>对象在接收到未知的消息时，首先会调用所属类的类方法<br>+resolveInstanceMethod:(实例方法)或者<br>+resolveClassMethod:(类方法)。</p><p>在这个方法中，我们有机会为该未知消息新增一个“处理方法”，通过运行时class_addMethod函数动态添加到类里面就可以了。<br>这种方案更多的是为了实现@dynamic属性。</p><p>备用接收者</p><p>如果在上一步无法处理消息，则Runtime会继续调以下方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</span><br></pre></td></tr></table></figure><p>如果一个对象实现了这个方法，并返回一个非nil的结果，则这个对象会作为消息的新接收者，且消息会被分发到这个对象。当然这个对象不能是self自身，否则就是出现无限循环。当然，如果我们没有指定相应的对象来处理aSelector，则应该调用父类的实现来返回结果。</p><p>这一步合适于我们只想将消息转发到另一个能处理该消息的对象上。但这一步无法对消息进行处理，如操作消息的参数和返回值</p><ul><li>完整消息转发</li></ul><p>如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。<br>我们首先要通过,指定方法签名，若返回nil，则表示不处理。<br>如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">   if ([NSStringFromSelector(aSelector) isEqualToString:@&quot;testInstanceMethod&quot;])&#123;</span><br><span class="line">     return [NSMethodSignature signatureWithObjcTypes:&quot;v@:&quot;];</span><br><span class="line">  &#125;  </span><br><span class="line">return [super methodSignatureForSelector: aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若返回方法签名，则会进入下一步调用以下方法，对象会创建一个表示消息的NSInvocation对象，把与尚未处理的消息有关的全部细节都封装在anInvocation中，包括selector，目标(target)和参数。<br>我们可以在forwardInvocation方法中选择将消息转发给其它对象。我们可以通过anInvocation对象做很多处理，比如修改实现方法，修改响应对象等.<br>如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)forwardInvovation:(NSInvocation)anInvocation</span><br><span class="line">&#123;</span><br><span class="line">    [anInvocation invokeWithTarget:_helper];</span><br><span class="line">    [anInvocation setSelector:@selector(run)];</span><br><span class="line">    [anInvocation invokeWithTarget:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h3><p>Swizzling原理</p><p>在Objective-C中调用一个方法，其实是向一个对象发送消息，而查找消息的唯一依据是selector的名字。所以，我们可以利用Objective-C的runtime机制，实现在运行时交换selector对应的方法实现以达到我们的目的。</p><p>每个类都有一个方法列表，存放着selector的名字和方法实现的映射关系。IMP有点类似函数指针，指向具体的Method实现</p><p>每一个SEL与一个IMP一一对应，正常情况下通过SEL可以查找到对应消息的IMP实现。</p><p>但是，现在我们要做的就是把链接线解开，然后连到我们自定义的函数的IMP上。当然，交换了两个SEL的IMP，还是可以再次交换回来了。</p><p>我们通过swizzling特性，将selectorC的方法实现IMPc与selectorN的方法实现IMPn交换了，当我们调用selectorC，也就是给对象发送selectorC消息时，所查找到的对应的方法实现就是IMPn而不是IMPc了</p><p>参考<a href="http://www.jianshu.com/p/adf0d566c887" target="_blank" rel="noopener">这里</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于运行时的简单剖析,查看上一篇即可,这里查看runtime消息的转发机制&lt;/p&gt;
&lt;h3 id=&quot;方法调用流程&quot;&gt;&lt;a href=&quot;#方法调用流程&quot; class=&quot;headerlink&quot; title=&quot;方法调用流程&quot;&gt;&lt;/a&gt;方法调用流程&lt;/h3&gt;&lt;p&gt;在Objective-C中，消息直到运行时才绑定到方法实现上。编译器会将消息表达式[receiver message]转化为一个消息函数的调用，即objc_msgSend。这个函数将消息接收者和方法名作为其基础参数，如以下所示&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;objc_msgSend(receiver, selector)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>10-Runtime简单剖析</title>
    <link href="http://zxn.wiki/2016/07/19/Runtime%E7%AE%80%E5%8D%95%E5%89%96%E6%9E%90/"/>
    <id>http://zxn.wiki/2016/07/19/Runtime%E7%AE%80%E5%8D%95%E5%89%96%E6%9E%90/</id>
    <published>2016-07-19T11:32:43.000Z</published>
    <updated>2021-06-25T02:55:08.395Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Runtime-概念"><a href="#Runtime-概念" class="headerlink" title="Runtime 概念"></a>Runtime 概念</h3><p>Objective C语言把能在运行期做的事情就推迟到运行期再决定。这就意味着，Objective C不仅需要一个编译器，而且需要一个运行期环境。这个运行期环境就是Runtime.</p><p>&lt;Excerpt in index | 首页摘要&gt;<br> <a id="more"></a><br>&lt;The rest of contents | 余下全文&gt;</p><h3 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构:"></a>基础结构:</h3><ul><li>objc_selector</li></ul><p>透明的数据结构，可以理解为C String</p><ul><li>SEL<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_selector *SEL;</span><br></pre></td></tr></table></figure></li></ul><p>SEL是指向一个C String的指针</p><ul><li>id<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure></li></ul><p>id － 指向一个类的实例对象</p><ul><li>objc_object</li></ul><p>objc_object是表示一个类的实例的结构体.<br>定义如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct objc_object &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure><p>可以看到，这个结构体只有一个字体，即指向其类的isa指针。这<br>样，当我们向一个Objective-C对象发送消息时，运行时库会根据<br>实例对象的isa指针找到这个实例对象所属的类。Runtime库会在类<br>的方法列表及父类的方法列表中去寻找与消息对应的selector指向<br>的方法，找到后即运行这个方法。</p><ul><li>Class</li></ul><p>Class － 指向Objective C类对象（objc_class）的一个指针</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_class *Class;</span><br></pre></td></tr></table></figure><ul><li>objc_class</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct object_class&#123;</span><br><span class="line">    Class isa OBJC_ISA_AVAILABILITY;</span><br><span class="line">#if !__OBJC2__</span><br><span class="line">     Class super_class                        OBJC2_UNAVAILABLE;  &#x2F;&#x2F; 父类</span><br><span class="line">     const char *name                         OBJC2_UNAVAILABLE;  &#x2F;&#x2F; 类名</span><br><span class="line">     long version                             OBJC2_UNAVAILABLE;  &#x2F;&#x2F; 类的版本信息，默认为0</span><br><span class="line">     long info                                OBJC2_UNAVAILABLE;  &#x2F;&#x2F; 类信息，供运行期使用的一些位标识</span><br><span class="line">     long instance_size                       OBJC2_UNAVAILABLE;  &#x2F;&#x2F; 该类的实例变量大小</span><br><span class="line">     struct objc_ivar_list *ivars             OBJC2_UNAVAILABLE;  &#x2F;&#x2F; 该类的成员变量链表</span><br><span class="line">     struct objc_method_list *methodLists     OBJC2_UNAVAILABLE;  &#x2F;&#x2F; 方法定义的链表</span><br><span class="line">     struct objc_cache *cache                 OBJC2_UNAVAILABLE;  &#x2F;&#x2F; 方法缓存</span><br><span class="line">     struct objc_protocol_list *protocols     OBJC2_UNAVAILABLE;  &#x2F;&#x2F; 协议链表</span><br><span class="line">#endif</span><br><span class="line">&#125;OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure><p>可以看到，这就是类对象结构体的定义</p><ul><li>method</li></ul><p>method - 指向Objective C中的方法的指针</p><ul><li><code>_cmd</code></li></ul><p>SEL 类型的一个变量，Objective C的函数的前两个隐藏参数为self 和 <code>_cmd</code></p><ul><li>Ivar</li></ul><p>ivar - objective C中的实例变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_ivar *Ivar;</span><br></pre></td></tr></table></figure><ul><li>元类(Meta Class):<br>在上面我们提到，所有的类自身也是一个对象，我们可以向这个对象发送消息(即调用类方法)。<br>既然是对象，那么它也是一个objc_object指针,它包含一个指向其类的一个isa指针。</li></ul><p>为了调用类方法，这个类的isa指针必须指向一个包含这些类方法的一个objc_class结构体。这就引出了meta-class的概念，meta-class中存储着一个类的所有类方法。<br>所以，调用类方法的这个类对象的isa指针指向的就是meta-class<br>当我们向一个对象发送消息时，runtime会在这个对象所属的这个类的方法列表中查找方法；而向一个类发送消息时，会在这个类的meta-class的方法列表中查找。</p><p>meta-class也是一个类，也可以向它发送一个消息.为了不让这种结构无限延伸下去，Objective-C的设计者让所有的meta-class的isa指向基类的meta-class，以此作为它们的所属类。也就是说 任何NSObject继承体系下的meta-class都使用NSObject的meta-class作为自己的所属类，而基类的meta-class的isa指针是指向它自己。</p><p><img src="img/runtime%E7%9A%84isa%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E5%9B%BE.png" alt=""></p><ul><li>Category</li></ul><p>Category是表示一个指向分类的结构体的指针</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_category *Category</span><br><span class="line">struct objc_category&#123;</span><br><span class="line">     char *category_name                         OBJC2_UNAVAILABLE; &#x2F;&#x2F; 分类名</span><br><span class="line">     char *class_name                            OBJC2_UNAVAILABLE;  &#x2F;&#x2F; 分类所属的类名</span><br><span class="line">     struct objc_method_list *instance_methods   OBJC2_UNAVAILABLE;  &#x2F;&#x2F; 实例方法列表</span><br><span class="line">     struct objc_method_list *class_methods      OBJC2_UNAVAILABLE; &#x2F;&#x2F; 类方法列表</span><br><span class="line">     struct objc_protocol_list *protocols        OBJC2_UNAVAILABLE; &#x2F;&#x2F; 分类所实现的协议列表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个结构体主要包含了分类定义的实例方法与类方法，其中instance_methods列表是objc_class中方法列表的一个子集，而class_methods列表是元类方法列表的一个子集。<br>可发现，类别中没有ivar成员变量指针，也就意味着：类别中不能够添加实例变量和属性</p><h3 id="runtime关联对象"><a href="#runtime关联对象" class="headerlink" title="runtime关联对象"></a>runtime关联对象</h3><ul><li>设置关联值</li></ul><p>object：与谁关联，通常是传self<br>key：唯一键，在获取值时通过该键获取，通常是使用 <code>static const void *</code> 来声明<br>value：关联所设置的值<br>policy：内存管理策略，比如使用copy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void objc_setAssociatedObject(id object, const void *key, id value, objc _AssociationPolicy policy)</span><br></pre></td></tr></table></figure><ul><li><p>获取关联值<br>object：与谁关联，通常是传self，在设置关联时所指定的与哪个对象关联的那个对象<br>key：唯一键，在设置关联时所指定的键</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id objc_getAssociatedObject(id object, const void *key)</span><br></pre></td></tr></table></figure></li><li><p>取消关联</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void objc_removeAssociatedObjects(id object)</span><br></pre></td></tr></table></figure></li><li><p>关联策略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy)&#123;</span><br><span class="line">OBJC_ASSOCIATION_ASSIGN &#x3D; 0,             &#x2F;&#x2F; 表示弱引用关联，通常是基本数据类型</span><br><span class="line">OBJC_ASSOCIATION_RETAIN_NONATOMIC &#x3D; 1,   &#x2F;&#x2F; 表示强引用关联对象，是线程安全的</span><br><span class="line">OBJC_ASSOCIATION_COPY_NONATOMIC &#x3D; 3,     &#x2F;&#x2F; 表示关联对象copy，是线程安全的</span><br><span class="line">OBJC_ASSOCIATION_RETAIN &#x3D; 01401,         &#x2F;&#x2F; 表示强引用关联对象，不是线程安全的</span><br><span class="line">OBJC_ASSOCIATION_COPY &#x3D; 01403            &#x2F;&#x2F; 表示关联对象copy，不是线程安全的</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法与消息"><a href="#方法与消息" class="headerlink" title="方法与消息"></a>方法与消息</h3><ul><li>SEL<br>SEL又叫选择器，是表示一个方法的selector的指针</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_selector *SEL；</span><br></pre></td></tr></table></figure><p>方法的selector用于表示运行时方法的名字。Objective-C在编译时，会依据每一个方法的名字、参数序列，生成一个唯一的整型标识(Int类型的地址)，这个标识就是SEL。<br>两个类之间，只要方法名相同，那么方法的SEL就是一样的，每一个方法都对应着一个SEL。所以在Objective-C同一个类(及类的继承体系)中，不能存在2个同名的方法，即使参数类型不同也不行</p><p>当然，不同的类可以拥有相同的selector，这个没有问题。不同类的实例对象执行相同的selector时，会在各自的方法列表中去根据selector去寻找自己对应的IMP。</p><p>工程中的所有的SEL组成一个Set集合，如果我们想到这个方法集合中查找某个方法时，只需要去找到这个方法对应的SEL就行了，SEL实际上就是根据方法名hash化了的一个字符串，而对于字符串的比较仅仅需要比较他们的地址就可以了，可以说速度上无语伦比！<br>本质上，SEL只是一个指向方法的指针（准确的说，只是一个根据方法名hash化了的KEY值，能唯一代表一个方法），它的存在只是为了加快方法的查询速度。<br>通过下面三种方法可以获取SEL:<br>a、sel_registerName函数<br>b、Objective-C编译器提供的@selector()<br>c、NSSelectorFromString()方法</p><ul><li>IMP<br>IMP实际上是一个函数指针，指向方法实现的地址。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id (*IMP)(id, SEL,...)</span><br></pre></td></tr></table></figure>第一个参数：是指向self的指针(如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)<br>第二个参数：是方法选择器(selector)<br>接下来的参数：方法的参数列表。</li></ul><p>前面介绍过的SEL就是为了查找方法的最终实现IMP的。由于每个方法对应唯一的SEL，因此我们可以通过SEL方便快速准确地获得它所对应的IMP，查找过程将在下面讨论。取得IMP后，我们就获得了执行这个方法代码的入口点，此时，我们就可以像调用普通的C语言函数一样来使用这个函数指针了</p><ul><li>Method</li></ul><p>Method用于表示类定义中的方法，则定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_method *Method</span><br><span class="line">struct objc_method&#123;</span><br><span class="line">    SEL method_name      OBJC2_UNAVAILABLE; &#x2F;&#x2F; 方法名</span><br><span class="line">    char *method_types   OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP method_imp       OBJC2_UNAVAILABLE; &#x2F;&#x2F; 方法实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到该结构体中包含一个SEL和IMP，实际上相当于在SEL和IMP之间作了一个映射。有了SEL，我们便可以找到对应的IMP，从而调用方法的实现代码。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Runtime-概念&quot;&gt;&lt;a href=&quot;#Runtime-概念&quot; class=&quot;headerlink&quot; title=&quot;Runtime 概念&quot;&gt;&lt;/a&gt;Runtime 概念&lt;/h3&gt;&lt;p&gt;Objective C语言把能在运行期做的事情就推迟到运行期再决定。这就意味着，Objective C不仅需要一个编译器，而且需要一个运行期环境。这个运行期环境就是Runtime.&lt;/p&gt;
&lt;p&gt;&amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>9-AFN2-0与3-0比较(三)</title>
    <link href="http://zxn.wiki/2016/06/17/AFN2-0%E4%B8%8E3-0%E6%AF%94%E8%BE%83(%E4%B8%89)/"/>
    <id>http://zxn.wiki/2016/06/17/AFN2-0%E4%B8%8E3-0%E6%AF%94%E8%BE%83(%E4%B8%89)/</id>
    <published>2016-06-17T12:49:51.000Z</published>
    <updated>2021-06-25T02:55:08.394Z</updated>
    
    <content type="html"><![CDATA[<p><code>AFURLSessionManager</code> 绝对可以称得上是 AFNetworking 的核心,在这里再一次地进行解析</p><p>&lt;Excerpt in index | 首页摘要&gt;<br> <a id="more"></a><br>&lt;The rest of contents | 余下全文&gt;</p><h3 id="AFURLSessionManager"><a href="#AFURLSessionManager" class="headerlink" title="AFURLSessionManager"></a>AFURLSessionManager</h3><p>首先，在 <code>AFURLSessionManager.h</code> 中关于 <code>AFURLSessionManager</code> 的概述：</p><ul><li>负责创建和管理 NSURLSession</li><li>管理 NSURLSessionTask</li><li>实现 NSURLSessionDelegate 等协议中的代理方法</li><li>使用 AFURLSessionManagerTaskDelegate 管理进度</li><li>使用 AFURLSessionTaskSwizzling 调剂方法</li><li>引入 AFSecurityPolicy 保证请求的安全</li><li>引入 AFNetworkReachabilityManager 监控网络状态</li></ul><h3 id="创建和管理-NSURLSession"><a href="#创建和管理-NSURLSession" class="headerlink" title="创建和管理 NSURLSession"></a>创建和管理 <code>NSURLSession</code></h3><p>按惯例，我们由 <code>AFURLSessionManager</code> 的初始化方法：<code>- (instancetype)initWithSessionConfiguration:(nullable NSURLSessionConfiguration *)configuration NS_DESIGNATED_INITIALIZER;</code> 进行展开：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration &#123;</span><br><span class="line">    self &#x3D; [super init];</span><br><span class="line">    if (!self) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!configuration) &#123;</span><br><span class="line">        configuration &#x3D; [NSURLSessionConfiguration defaultSessionConfiguration];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self.sessionConfiguration &#x3D; configuration;</span><br><span class="line"></span><br><span class="line">    self.operationQueue &#x3D; [[NSOperationQueue alloc] init];</span><br><span class="line">    self.operationQueue.maxConcurrentOperationCount &#x3D; 1;</span><br><span class="line"></span><br><span class="line">    self.session &#x3D; [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue];</span><br><span class="line"></span><br><span class="line">    self.responseSerializer &#x3D; [AFJSONResponseSerializer serializer];</span><br><span class="line"></span><br><span class="line">    self.securityPolicy &#x3D; [AFSecurityPolicy defaultPolicy];</span><br><span class="line"></span><br><span class="line">#if !TARGET_OS_WATCH</span><br><span class="line">    self.reachabilityManager &#x3D; [AFNetworkReachabilityManager sharedManager];</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    self.mutableTaskDelegatesKeyedByTaskIdentifier &#x3D; [[NSMutableDictionary alloc] init];</span><br><span class="line"></span><br><span class="line">    self.lock &#x3D; [[NSLock alloc] init];</span><br><span class="line">    self.lock.name &#x3D; AFURLSessionManagerLockName;</span><br><span class="line"></span><br><span class="line">    [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) &#123;</span><br><span class="line">        for (NSURLSessionDataTask *task in dataTasks) &#123;</span><br><span class="line">            [self addDelegateForDataTask:task uploadProgress:nil downloadProgress:nil completionHandler:nil];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (NSURLSessionUploadTask *uploadTask in uploadTasks) &#123;</span><br><span class="line">            [self addDelegateForUploadTask:uploadTask progress:nil completionHandler:nil];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (NSURLSessionDownloadTask *downloadTask in downloadTasks) &#123;</span><br><span class="line">            [self addDelegateForDownloadTask:downloadTask progress:nil destination:nil completionHandler:nil];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法主要完成如下工作：</p><pre><code>1 . 初始化 **会话配置**（NSURLSessionConfiguration），默认为 `defaultSessionConfiguration`2 . 设置相应的 `OperationQueue`，决定请求过程中的一系列事件在哪个 `OperationQueue` 回调，这里是设置了最大并发量为 1 的队列，也就相当于串行队列了。(AFNetworing 2.0 版本是设置了一条常驻线程来响应所有网络请求的 delegate 事件)3 . 初始化会话（session），并设置会话的代理及代理队列，delegate 用来处理请求中的各种事件，可以设置为 nil 使用系统提供的 delegate，但是要想支持后台传输数据必须提供自定义实现的 delegate；另外，`NSURLSession` 对象是强引用了 delegate，如果程序最终没有调用 `invalidateAndCancel` 方法来 invalidate 该 session 的话，则会造成内存泄漏4 . 初始化管理 **响应序列化**（AFJSONResponseSerializer），**安全认证**（AFSecurityPolicy）以及 **监控网络状态**（AFNetworkReachabilityManager）的实例5 . 初始化保存 data task 的字典（mutableTaskDelegatesKeyedByTaskIdentifier）</code></pre><h3 id="管理-NSURLSessionTask"><a href="#管理-NSURLSessionTask" class="headerlink" title="管理 NSURLSessionTask"></a>管理 <code>NSURLSessionTask</code></h3><p>接下来，在获得了 <code>AFURLSessionManager</code> 的实例之后，我们可以通过以下方法创建 <code>NSURLSessionDataTask</code> 的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> Creates an &#96;NSURLSessionDataTask&#96; with the specified request.</span><br><span class="line"></span><br><span class="line"> @param request The HTTP request for the request.</span><br><span class="line"> @param completionHandler A block object to be executed when the task finishes. This block has no return value and takes three arguments: the server response, the response object created by that serializer, and the error that occurred, if any.</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request</span><br><span class="line">                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</span><br><span class="line">                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</span><br><span class="line">                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这里省略了一些返回 <code>NSURLSessionTask</code> 的方法，因为这些接口的形式都是差不多的。</p><p>下面，我们将以 <code>- [AFURLSessionManager dataTaskWithRequest:uploadProgress:downloadProgress:completionHandler:]</code> 方法的实现为例，分析它是如何实例化并返回一个 <code>NSURLSessionTask</code> 的实例的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request</span><br><span class="line">                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</span><br><span class="line">                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</span><br><span class="line">                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler &#123;</span><br><span class="line"></span><br><span class="line">    __block NSURLSessionDataTask *dataTask &#x3D; nil;</span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        dataTask &#x3D; [self.session dataTaskWithRequest:request];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line">    return dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法主要完成如下工作：</p><ul><li>调用 <code>- [NSURLSession dataTaskWithRequest:]</code> 方法传入 <code>NSURLRequest</code></li><li>调用 <code>- [AFURLSessionManager addDelegateForDataTask:uploadProgress:downloadProgress:completionHandler:] 方法返回一个 AFURLSessionManagerTaskDelegate</code> 对象</li><li>将 <code>completionHandler uploadProgressBlock</code> 和 <code>downloadProgressBlock</code> 传入该对象并在相应事件发生时进行回调</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">                uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</span><br><span class="line">              downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</span><br><span class="line">             completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate &#x3D; [[AFURLSessionManagerTaskDelegate alloc] init];</span><br><span class="line">    delegate.manager &#x3D; self;</span><br><span class="line">    delegate.completionHandler &#x3D; completionHandler;</span><br><span class="line"></span><br><span class="line">    dataTask.taskDescription &#x3D; self.taskDescriptionForSessionTasks;</span><br><span class="line">    [self setDelegate:delegate forTask:dataTask];</span><br><span class="line"></span><br><span class="line">    delegate.uploadProgressBlock &#x3D; uploadProgressBlock;</span><br><span class="line">    delegate.downloadProgressBlock &#x3D; downloadProgressBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中同时调用了另一个方法 <code>- [AFURLSessionManager setDelegate:forTask:]</code> 来设置代理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</span><br><span class="line">            forTask:(NSURLSessionTask *)task</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    #1: 检查参数, 略</span><br><span class="line"></span><br><span class="line">    [self.lock lock];</span><br><span class="line">    self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] &#x3D; delegate;</span><br><span class="line">    [delegate setupProgressForTask:task];</span><br><span class="line">    [self addNotificationObserverForTask:task];</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如上面所提到的，<code>AFURLSessionManager</code> 就是通过字典 <code>mutableTaskDelegatesKeyedByTaskIdentifier</code> 来存储并管理每一个 <code>NSURLSessionTask</code>，它以 <code>taskIdentifier</code> 为键存储 <code>task</code>。</p><p>该方法使用 NSLock 来保证不同线程使用 <code>mutableTaskDelegatesKeyedByTaskIdentifier</code> 时，不会出现线程竞争的问题（既线程同步）。</p><p>同时调用 <code>- setupProgressForTask:</code>，我们会在下面具体介绍这个方法。</p><h3 id="实现-NSURLSessionDelegate-等协议中的代理方法"><a href="#实现-NSURLSessionDelegate-等协议中的代理方法" class="headerlink" title="实现 NSURLSessionDelegate 等协议中的代理方法"></a>实现 <code>NSURLSessionDelegate</code> 等协议中的代理方法</h3><p>首先查看NSURLSessionDelegate的结构:<br><img src="/img/NSURLSessionDelegate.png" alt=""></p><p>接下来，我们来看下具体的代理方法：</p><ul><li><code>NSURLSessionDelegate</code></li><li><code>NSURLSessionTaskDelegate</code>，遵守 <code>NSURLSessionDelegate</code> 协议</li><li><code>NSURLSessionDataDelegate</code>，遵守 <code>NSURLSessionTaskDelegate</code> 协议，是网络请求通常遵循的协议，常用的方法：</li></ul><pre><code>1 . 接受到服务响应时调用的方法</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 必须在该方法中对服务器的响应进行授权，才能继续接收服务器返回的数据，调用如下函数</span><br><span class="line">* completionHandler（NSURLSessionResponseAllow）</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><p>  2 . 接收到服务器返回的数据时调用的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data</span><br><span class="line">&#x2F;**</span><br><span class="line">* data：服务返回的数据，通常为 JSON 格式数据</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><p>  3 . 请求完成时调用的方法（成功或失败）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(nullable NSError *)error</span><br><span class="line">&#x2F;**</span><br><span class="line">* 若出现错误，error 中存放错误信息</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><ul><li>NSURLSessionDownloadDelegate（通常用于下载大量数据），遵守 NSURLSessionTaskDelegate 协议，常用的方法：</li></ul><p>1 . 写入数据到临时文件时调用的方法（服务器返回一点就写入一点）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite</span><br><span class="line">&#x2F;**</span><br><span class="line">* totalBytesWritten，已写入数据的总长度</span><br><span class="line">* totalBytesExpectedToWrite：总共要写入数据的总长度</span><br><span class="line">* 可以在该方法中计算下载进度</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><p>2 . 遇到错误的时候调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error</span><br></pre></td></tr></table></figure><p>3 . 用于断点下载的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* fileOffset：继续下载时，文件的开始位置</span><br><span class="line">* expectedTotalBytes：剩余的数据总数</span><br><span class="line">*&#x2F;</span><br><span class="line">- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didResumeAtOffset:(int64_t)fileOffset expectedTotalBytes:(int64_t)expectedTotalBytes</span><br></pre></td></tr></table></figure><p>4 . 下载完成时调用的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* location：下载的文件保存的临时位置</span><br><span class="line">* 需要将下载的文件保存在可以长期保存的位置</span><br><span class="line">*&#x2F;</span><br><span class="line">- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(NSURL *)location</span><br></pre></td></tr></table></figure><h3 id="使用-AFURLSessionManagerTaskDelegate-管理进度"><a href="#使用-AFURLSessionManagerTaskDelegate-管理进度" class="headerlink" title="使用 AFURLSessionManagerTaskDelegate 管理进度"></a>使用 <code>AFURLSessionManagerTaskDelegate</code> 管理进度</h3><p>在上面我们提到过 <code>AFURLSessionManagerTaskDelegate</code> 类，它主要为 task 提供进度管理功能，并在 task 结束时回调， 也就是调用在 <code>- [AFURLSessionManager dataTaskWithRequest:uploadProgress:downloadProgress:completionHandler:] 等方法中传入的 completionHandler</code>。</p><p>我们首先分析一下 <code>AFURLSessionManagerTaskDelegate</code> 是如何对进度进行跟踪的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)setupProgressForTask:(NSURLSessionTask *)task &#123;</span><br><span class="line"></span><br><span class="line">    #1：设置在上传进度或者下载进度状态改变时的回调</span><br><span class="line">true</span><br><span class="line">    #2：KVO</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的实现有两个部分，一部分是对代理持有的两个属性 <code>uploadProgress</code> 和 <code>downloadProgress</code> 设置回调</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">__weak __typeof__(task) weakTask &#x3D; task;</span><br><span class="line"></span><br><span class="line">self.uploadProgress.totalUnitCount &#x3D; task.countOfBytesExpectedToSend;</span><br><span class="line">[self.uploadProgress setCancellable:YES];</span><br><span class="line">[self.uploadProgress setCancellationHandler:^&#123;</span><br><span class="line">   __typeof__(weakTask) strongTask &#x3D; weakTask;</span><br><span class="line">   [strongTask cancel];</span><br><span class="line">&#125;];</span><br><span class="line">[self.uploadProgress setPausable:YES];</span><br><span class="line">[self.uploadProgress setPausingHandler:^&#123;</span><br><span class="line">   __typeof__(weakTask) strongTask &#x3D; weakTask;</span><br><span class="line">   [strongTask suspend];</span><br><span class="line">&#125;];</span><br><span class="line">if ([self.uploadProgress respondsToSelector:@selector(setResumingHandler:)]) &#123;</span><br><span class="line">   [self.uploadProgress setResumingHandler:^&#123;</span><br><span class="line">       __typeof__(weakTask) strongTask &#x3D; weakTask;</span><br><span class="line">       [strongTask resume];</span><br><span class="line">   &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只有对 <code>uploadProgress</code> 设置回调的代码，设置 <code>downloadProgress</code> 与这里完全相同</p><p>主要目的是在对应 <code>NSProgress</code> 的状态改变时，调用 <code>resume</code> <code>suspend</code> 等方法改变 task 的状态。</p><p>第二部分是对 <code>task</code> 和 <code>NSProgress</code> 属性进行键值观测：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[task addObserver:self</span><br><span class="line">      forKeyPath:NSStringFromSelector(@selector(countOfBytesReceived))</span><br><span class="line">         options:NSKeyValueObservingOptionNew</span><br><span class="line">         context:NULL];</span><br><span class="line">[task addObserver:self</span><br><span class="line">      forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))</span><br><span class="line">         options:NSKeyValueObservingOptionNew</span><br><span class="line">         context:NULL];</span><br><span class="line"></span><br><span class="line">[task addObserver:self</span><br><span class="line">      forKeyPath:NSStringFromSelector(@selector(countOfBytesSent))</span><br><span class="line">         options:NSKeyValueObservingOptionNew</span><br><span class="line">         context:NULL];</span><br><span class="line">[task addObserver:self</span><br><span class="line">      forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToSend))</span><br><span class="line">         options:NSKeyValueObservingOptionNew</span><br><span class="line">         context:NULL];</span><br><span class="line"></span><br><span class="line">[self.downloadProgress addObserver:self</span><br><span class="line">                       forKeyPath:NSStringFromSelector(@selector(fractionCompleted))</span><br><span class="line">                          options:NSKeyValueObservingOptionNew</span><br><span class="line">                          context:NULL];</span><br><span class="line">[self.uploadProgress addObserver:self</span><br><span class="line">                     forKeyPath:NSStringFromSelector(@selector(fractionCompleted))</span><br><span class="line">                        options:NSKeyValueObservingOptionNew</span><br><span class="line">                        context:NULL];</span><br></pre></td></tr></table></figure><p>在 <code>observeValueForKeypath:ofObject:change:context:</code> 方法中改变进度，并调用 block</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context &#123;</span><br><span class="line">    if ([object isKindOfClass:[NSURLSessionTask class]]) &#123;</span><br><span class="line">        if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesReceived))]) &#123;</span><br><span class="line">            self.downloadProgress.completedUnitCount &#x3D; [change[@&quot;new&quot;] longLongValue];</span><br><span class="line">        &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))]) &#123;</span><br><span class="line">            self.downloadProgress.totalUnitCount &#x3D; [change[@&quot;new&quot;] longLongValue];</span><br><span class="line">        &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesSent))]) &#123;</span><br><span class="line">            self.uploadProgress.completedUnitCount &#x3D; [change[@&quot;new&quot;] longLongValue];</span><br><span class="line">        &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesExpectedToSend))]) &#123;</span><br><span class="line">            self.uploadProgress.totalUnitCount &#x3D; [change[@&quot;new&quot;] longLongValue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if ([object isEqual:self.downloadProgress]) &#123;</span><br><span class="line">        if (self.downloadProgressBlock) &#123;</span><br><span class="line">            self.downloadProgressBlock(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if ([object isEqual:self.uploadProgress]) &#123;</span><br><span class="line">        if (self.uploadProgressBlock) &#123;</span><br><span class="line">            self.uploadProgressBlock(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代理方法-URLSession-task-didCompleteWithError"><a href="#代理方法-URLSession-task-didCompleteWithError" class="headerlink" title="代理方法 URLSession:task:didCompleteWithError:"></a>代理方法 <code>URLSession:task:didCompleteWithError:</code></h3><p>在每一个 <code>NSURLSessionTask</code> 结束时，都会在代理方法 <code>URLSession:task:didCompleteWithError:</code> 中：<br>1 . 调用传入的 <code>completionHander</code> block<br>2 . 发出 <code>AFNetworkingTaskDidCompleteNotification</code> 通知</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(__unused NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line">didCompleteWithError:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line">    #1：获取数据, 存储 &#96;responseSerializer&#96; 和 &#96;downloadFileURL&#96;</span><br><span class="line"></span><br><span class="line">    if (error) &#123;</span><br><span class="line">    #2：在存在错误时调用 &#96;completionHandler&#96;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">truetrue#3：调用 &#96;completionHandler&#96;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是整个代理方法的骨架，先看一下最简单的第一部分代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">__block NSMutableDictionary *userInfo &#x3D; [NSMutableDictionary dictionary];</span><br><span class="line">userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] &#x3D; manager.responseSerializer;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 具体可以查看 #issue 2672。这里主要是针对大文件的时候，性能提升会很明显</span><br><span class="line">NSData *data &#x3D; nil;</span><br><span class="line">if (self.mutableData) &#123;</span><br><span class="line">   data &#x3D; [self.mutableData copy];</span><br><span class="line">   &#x2F;&#x2F; 此处不再需要 mutableData 了</span><br><span class="line">   self.mutableData &#x3D; nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (self.downloadFileURL) &#123;</span><br><span class="line">   userInfo[AFNetworkingTaskDidCompleteAssetPathKey] &#x3D; self.downloadFileURL;</span><br><span class="line">&#125; else if (data) &#123;</span><br><span class="line">   userInfo[AFNetworkingTaskDidCompleteResponseDataKey] &#x3D; data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看第二部分：这部分代码从 <code>mutableData</code> 中取出了数据，设置了 <code>userInfo</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果 task 出错了，处理 error 信息</span><br><span class="line">&#x2F;&#x2F; 所以对应的观察者在处理 error 的时候，比如可以先判断 userInfo[AFNetworkingTaskDidCompleteErrorKey] 是否有值，有值的话，就说明是要处理 error</span><br><span class="line">userInfo[AFNetworkingTaskDidCompleteErrorKey] &#x3D; error;</span><br><span class="line"></span><br><span class="line">dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    if (self.completionHandler) &#123;</span><br><span class="line">        self.completionHandler(task.response, responseObject, error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果当前 <code>manager</code> 持有 <code>completionGroup</code> 或者 <code>completionQueue</code> 就使用它们。否则会创建一个 <code>dispatch_group_t</code> 并在主线程中调用 <code>completionHandler</code> 并发送通知（在主线程中）。<br>最后一部分：如果在执行当前 task 时没有遇到错误，那么先对数据进行序列化，然后同样调用 block 并发送通知。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(url_session_manager_processing_queue(), ^&#123;</span><br><span class="line">    NSError *serializationError &#x3D; nil;</span><br><span class="line">    &#x2F;&#x2F; 根据对应的 task 和 data 将 response data 解析成可用的数据格式，比如 JSON serializer 就将 data 解析成 JSON 格式</span><br><span class="line">    responseObject &#x3D; [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];</span><br><span class="line">    &#x2F;&#x2F; 注意如果有 downloadFileURL，意味着 data 存放在了磁盘上了，所以此处 responseObject 保存的是 data 存放位置，供后面 completionHandler 处理。没有 downloadFileURL，就直接使用内存中的解析后的 data 数据</span><br><span class="line">    if (self.downloadFileURL) &#123;</span><br><span class="line">        responseObject &#x3D; self.downloadFileURL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (responseObject) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] &#x3D; responseObject;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 序列化的时候出现错误</span><br><span class="line">    if (serializationError) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteErrorKey] &#x3D; serializationError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        if (self.completionHandler) &#123;</span><br><span class="line">            self.completionHandler(task.response, responseObject, serializationError);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>代理方法 <code>URLSession:dataTask:didReceiveData:</code> 和 <code>- URLSession:downloadTask:didFinishDownloadingToURL:</code></p><p>这两个代理方法分别会在收到数据或者完成下载对应文件时调用，作用分别是为 mutableData 追加数据和处理下载的文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(__unused NSURLSession *)session</span><br><span class="line">          dataTask:(__unused NSURLSessionDataTask *)dataTask</span><br><span class="line">    didReceiveData:(NSData *)data</span><br><span class="line">&#123;</span><br><span class="line">    [self.mutableData appendData:data];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">      downloadTask:(NSURLSessionDownloadTask *)downloadTask</span><br><span class="line">didFinishDownloadingToURL:(NSURL *)location</span><br><span class="line">&#123;</span><br><span class="line">    NSError *fileManagerError &#x3D; nil;</span><br><span class="line">    self.downloadFileURL &#x3D; nil;</span><br><span class="line"></span><br><span class="line">    if (self.downloadTaskDidFinishDownloading) &#123;</span><br><span class="line">        self.downloadFileURL &#x3D; self.downloadTaskDidFinishDownloading(session, downloadTask, location);</span><br><span class="line">        if (self.downloadFileURL) &#123;</span><br><span class="line">            [[NSFileManager defaultManager] moveItemAtURL:location toURL:self.downloadFileURL error:&amp;fileManagerError];</span><br><span class="line"></span><br><span class="line">            if (fileManagerError) &#123;</span><br><span class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-AFURLSessionTaskSwizzling-调剂方法"><a href="#使用-AFURLSessionTaskSwizzling-调剂方法" class="headerlink" title="使用 AFURLSessionTaskSwizzling 调剂方法"></a>使用 <code>AFURLSessionTaskSwizzling</code> 调剂方法</h3><p><code>AFURLSessionTaskSwizzling</code> 的唯一功能就是修改 <code>NSURLSessionTask</code> 的 <code>resume</code> 和 <code>suspend</code> 方法，使用下面的方法替换原有的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)af_resume &#123;</span><br><span class="line">    NSAssert([self respondsToSelector:@selector(state)], @&quot;Does not respond to state&quot;);</span><br><span class="line">    NSURLSessionTaskState state &#x3D; [self state];</span><br><span class="line">    [self af_resume];</span><br><span class="line"></span><br><span class="line">    if (state !&#x3D; NSURLSessionTaskStateRunning) &#123;</span><br><span class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidResumeNotification object:self];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)af_suspend &#123;</span><br><span class="line">    NSAssert([self respondsToSelector:@selector(state)], @&quot;Does not respond to state&quot;);</span><br><span class="line">    NSURLSessionTaskState state &#x3D; [self state];</span><br><span class="line">    [self af_suspend];</span><br><span class="line"></span><br><span class="line">    if (state !&#x3D; NSURLSessionTaskStateSuspended) &#123;</span><br><span class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidSuspendNotification object:self];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做的目的是为了在方法 <code>resume</code> 或者 <code>suspend</code> 被调用时发出通知。</p><p>具体方法调剂的过程是在 <code>+ load</code> 方法中进行的</p><p><code>load</code> 方法只会在整个文件被引入时调用一次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load &#123;</span><br><span class="line">    if (NSClassFromString(@&quot;NSURLSessionTask&quot;)) &#123;</span><br><span class="line">        NSURLSessionConfiguration *configuration &#x3D; [NSURLSessionConfiguration ephemeralSessionConfiguration];</span><br><span class="line">        &#x2F;&#x2F; 首先构建一个 NSURLSession 对象 session，再通过 session 构建出一个 _NSCFLocalDataTask 变量</span><br><span class="line">        NSURLSession * session &#x3D; [NSURLSession sessionWithConfiguration:configuration];</span><br><span class="line">#pragma GCC diagnostic push</span><br><span class="line">#pragma GCC diagnostic ignored &quot;-Wnonnull&quot;</span><br><span class="line">        NSURLSessionDataTask *localDataTask &#x3D; [session dataTaskWithURL:nil];</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">        &#x2F;&#x2F; 获取到 af_resume 实现的指针</span><br><span class="line">        IMP originalAFResumeIMP &#x3D; method_getImplementation(class_getInstanceMethod([self class], @selector(af_resume)));</span><br><span class="line">        Class currentClass &#x3D; [localDataTask class];</span><br><span class="line">        &#x2F;&#x2F; 检查当前 class 是否实现了 resume。如果实现了，继续第 4 步</span><br><span class="line">        while (class_getInstanceMethod(currentClass, @selector(resume))) &#123;</span><br><span class="line">            &#x2F;&#x2F; 获取到当前 class 的父类（superClass）</span><br><span class="line">            Class superClass &#x3D; [currentClass superclass];</span><br><span class="line">            &#x2F;&#x2F; 获取到当前 class 对于 resume 实现的指针</span><br><span class="line">            IMP classResumeIMP &#x3D; method_getImplementation(class_getInstanceMethod(currentClass, @selector(resume)));</span><br><span class="line">            &#x2F;&#x2F; 获取到父类对于 resume 实现的指针</span><br><span class="line">            IMP superclassResumeIMP &#x3D; method_getImplementation(class_getInstanceMethod(superClass, @selector(resume)));</span><br><span class="line">            &#x2F;&#x2F; 如果当前 class 对于 resume 的实现和父类不一样（类似 iOS 7 上的情况），并且当前 class 的 resume 实现和 af_resume 不一样，才进行 method swizzling</span><br><span class="line">            if (classResumeIMP !&#x3D; superclassResumeIMP &amp;&amp;</span><br><span class="line">                originalAFResumeIMP !&#x3D; classResumeIMP) &#123;</span><br><span class="line">                [self swizzleResumeAndSuspendMethodForClass:currentClass];</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 设置当前操作的 class 为其父类 class，重复步骤 3~8</span><br><span class="line">            currentClass &#x3D; [currentClass superclass];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [localDataTask cancel];</span><br><span class="line">        [session finishTasksAndInvalidate];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1 . 首先用 <code>NSClassFromString(@&quot;NSURLSessionTask&quot;)</code> 判断当前部署的 iOS 版本是否含有类 <code>NSURLSessionTask</code><br>2 . 因为 iOS 7 和 iOS 8 上对于 <code>NSURLSessionTask</code> 的实现不同，所以会通过 <code>- [NSURLSession dataTaskWithURL:]</code> 方法返回一个 NSURLSessionTask 实例<br>3 . 取得当前类 <code>AFURLSessionTaskSwizzling</code> 中的实现 af_resume<br>4 . 如果当前类 <code>currentClass</code>  <strong>有</strong> resume 方法<br>5 . 使用 <code>swizzleResumeAndSuspendMethodForClass:</code> 调剂该类的 resume 和 suspend 方法<br>6 . 如果当前类 <code>currentClass</code>  <strong>没有</strong> resume 方法,<code>currentClass = [currentClass superclass]</code></p><h3 id="引入-AFSecurityPolicy-保证请求的安全"><a href="#引入-AFSecurityPolicy-保证请求的安全" class="headerlink" title="引入 AFSecurityPolicy 保证请求的安全"></a>引入 <code>AFSecurityPolicy</code> 保证请求的安全</h3><p><code>AFSecurityPolicy</code> 是 AFNetworking 用来保证 HTTP 请求安全的类，它被 <code>AFURLSessionManager</code> 持有，如果你在 <code>AFURLSessionManager</code> 的实现文件中搜索 self.securityPolicy，你只会得到三条结果：</p><blockquote><p>初始化 <code>self.securityPolicy = [AFSecurityPolicy defaultPolicy]</code><br>收到连接层的验证请求时<br>任务接收到验证请求时</p></blockquote><p>在 API 调用上，后两者都调用了 <code>- [AFSecurityPolicy evaluateServerTrust:forDomain:]</code> 方法来判断当前服务器是否被信任，我们会在接下来的文章中具体介绍这个方法的实现的作用。</p><h3 id="引入-AFNetworkReachabilityManager-监控网络状态"><a href="#引入-AFNetworkReachabilityManager-监控网络状态" class="headerlink" title="引入 AFNetworkReachabilityManager 监控网络状态"></a>引入 <code>AFNetworkReachabilityManager</code> 监控网络状态</h3><p>与 <code>AFSecurityPolicy</code> 相同，<code>AFURLSessionManager</code> 对网络状态的监控是由 <code>AFNetworkReachabilityManager</code> 来负责的，它仅仅是持有一个 <code>AFNetworkReachabilityManager</code> 的对象。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li><code>AFURLSessionManager</code> 是对 NSURLSession 的封装</li><li>它通过 <code>- [AFURLSessionManager dataTaskWithRequest:completionHandler:]</code> 等接口创建 <code>NSURLSessionDataTask</code> 的实例</li><li>持有一个字典 <code>mutableTaskDelegatesKeyedByTaskIdentifier</code> 管理这些 data task 实例</li><li>引入 <code>AFURLSessionManagerTaskDelegate</code> 来对传入的 <code>uploadProgressBlock downloadProgressBlock completionHandler</code> 在合适的时间进行调用</li><li>实现了全部的代理方法来提供 block 接口</li><li>通过方法调剂在 data task 状态改变时，发出通知</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;AFURLSessionManager&lt;/code&gt; 绝对可以称得上是 AFNetworking 的核心,在这里再一次地进行解析&lt;/p&gt;
&lt;p&gt;&amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>8-AFN2-0与3-0比较(二)</title>
    <link href="http://zxn.wiki/2016/06/13/AFN2-0%E4%B8%8E3-0%E6%AF%94%E8%BE%83(%E4%BA%8C)/"/>
    <id>http://zxn.wiki/2016/06/13/AFN2-0%E4%B8%8E3-0%E6%AF%94%E8%BE%83(%E4%BA%8C)/</id>
    <published>2016-06-13T14:16:30.000Z</published>
    <updated>2021-06-25T02:55:08.394Z</updated>
    
    <content type="html"><![CDATA[<p>首先，我们来看一下 AFNetworking 框架中主要涉及到了哪些类：</p><p>NSURLSession:</p><ul><li>AFURLSessionManager</li><li>AFHTTPSessionManager</li></ul><p>序列化:</p><ul><li>AFURLRequestSerialization</li><li>AFURLResponseSerialization</li></ul><p>附加功能:</p><ul><li>AFSecurityPolicy</li><li>AFNetworkReachabilityManager</li></ul><p>&lt;Excerpt in index | 首页摘要&gt;<br> <a id="more"></a><br>&lt;The rest of contents | 余下全文&gt;</p><p>AFN 架构的设计如图:<br><img src="/img/AFN%E6%9E%B6%E6%9E%84%E6%A1%86%E6%9E%B6.png" alt=""></p><h3 id="AFHTTPSessionManager"><a href="#AFHTTPSessionManager" class="headerlink" title="AFHTTPSessionManager"></a>AFHTTPSessionManager</h3><p><code>AFHTTPSessionManager</code> 继承于 <code>AFURLSessionManager</code>，并提供了方便的 HTTP 请求方法。</p><p>demo:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AFHTTPSessionManager *sessionManager &#x3D; [[AFHTTPSessionManager alloc] initWithBaseURL:[NSURL URLWithString:@&quot;https:&#x2F;&#x2F;api.xxxx.com&#x2F;&quot;]];</span><br><span class="line">[sessionManager GET:@&quot;stream&#x2F;0&#x2F;posts&#x2F;stream&#x2F;global&quot; parameters:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nonnull responseObject) &#123;</span><br><span class="line">    NSLog(@&quot;请求成功---%@&quot;, responseObject);</span><br><span class="line">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class="line">    NSLog(@&quot;请求失败---%@&quot;, error);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>通过上面短短几行代码，我们便完成了 GET 请求，有木有很简单！现在是不是很想知道其背后蕴藏的玄机呢？别急，下面就让我们一起来探一探究竟。</p><h3 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h3><h3 id="initWithBaseURL"><a href="#initWithBaseURL" class="headerlink" title="initWithBaseURL:"></a>initWithBaseURL:</h3><p>首先，我们来探一探 <code>AFHTTPSessionManager</code> 初始化方法 <code>- initWithBaseURL:</code> 的调用栈：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AFHTTPSessionManager *sessionManager &#x3D; [[AFHTTPSessionManager alloc] initWithBaseURL:[NSURL URLWithString:@&quot;https:&#x2F;&#x2F;api.xxx.com&quot;]];</span><br></pre></td></tr></table></figure><p>根据调试方法步骤看到:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- [AFHTTPSessionManager initWithBaseURL:]</span><br><span class="line">    - [AFHTTPSessionManager initWithBaseURL:sessionConfiguration:]</span><br><span class="line">        - [AFURLSessionManager initWithSessionConfiguration:]</span><br><span class="line">            - [NSURLSession sessionWithConfiguration:delegate:delegateQueue:]</span><br><span class="line">            - [AFJSONResponseSerializer serializer] &#x2F;&#x2F; 负责序列化响应</span><br><span class="line">            - [AFSecurityPolicy defaultPolicy] &#x2F;&#x2F; 负责身份认证</span><br><span class="line">            - [AFNetworkReachabilityManager sharedManager] &#x2F;&#x2F; 查看网络连接情况</span><br><span class="line">        - [AFHTTPRequestSerializer serializer] &#x2F;&#x2F; 负责序列化请求</span><br><span class="line">        - [AFJSONResponseSerializer serializer] &#x2F;&#x2F; 负责序列化响应</span><br></pre></td></tr></table></figure><p>从这个初始化方法的调用栈，我们可以非常清晰地了解这个框架的结构：</p><ul><li>其中 <code>AFURLSessionManager</code> 是 <code>AFHTTPSessionManager</code> 的父类</li><li><code>AFURLSessionManager</code> 负责生成 <code>NSURLSession</code> 的实例，管理 <code>AFSecurityPolicy</code> 和 <code>AFNetworkReachabilityManager</code>，来保证请求的安全和查看网络连接情况，它有一个 <code>AFJSONResponseSerializer</code> 的实例来序列化 HTTP 响应</li><li><code>AFHTTPSessionManager</code> 有着自己的 <code>AFHTTPRequestSerializer</code> 和 <code>AFJSONResponseSerializer</code> 来管理请求和响应的序列化，同时依赖父类提供的接口保证安全、监控网络状态，实现发出 HTTP 请求这一核心功能</li></ul><h3 id="baseURL"><a href="#baseURL" class="headerlink" title="baseURL"></a>baseURL</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSURL *baseURL &#x3D; [NSURL URLWithString:@&quot;http:&#x2F;&#x2F;example.com&#x2F;v1&#x2F;&quot;];</span><br><span class="line">[NSURL URLWithString:@&quot;foo&quot; relativeToURL:baseURL];                  &#x2F;&#x2F; http:&#x2F;&#x2F;example.com&#x2F;v1&#x2F;foo</span><br><span class="line">[NSURL URLWithString:@&quot;foo?bar&#x3D;baz&quot; relativeToURL:baseURL];          &#x2F;&#x2F; http:&#x2F;&#x2F;example.com&#x2F;v1&#x2F;foo?bar&#x3D;baz</span><br><span class="line">[NSURL URLWithString:@&quot;&#x2F;foo&quot; relativeToURL:baseURL];                 &#x2F;&#x2F; http:&#x2F;&#x2F;example.com&#x2F;foo</span><br><span class="line">[NSURL URLWithString:@&quot;foo&#x2F;&quot; relativeToURL:baseURL];                 &#x2F;&#x2F; http:&#x2F;&#x2F;example.com&#x2F;v1&#x2F;foo</span><br><span class="line">[NSURL URLWithString:@&quot;&#x2F;foo&#x2F;&quot; relativeToURL:baseURL];                &#x2F;&#x2F; http:&#x2F;&#x2F;example.com&#x2F;foo&#x2F;</span><br><span class="line">[NSURL URLWithString:@&quot;http:&#x2F;&#x2F;example2.com&#x2F;&quot; relativeToURL:baseURL]; &#x2F;&#x2F; http:&#x2F;&#x2F;example2.com&#x2F;</span><br></pre></td></tr></table></figure><p><code>baseURL</code> 为访问的基路径如：<a href="https://api.app.net/，" target="_blank" rel="noopener">https://api.app.net/，</a> path 是跟在基路径之后的部分路径</p><h3 id="GET-parameters-process-success-failure"><a href="#GET-parameters-process-success-failure" class="headerlink" title="GET:parameters:process:success:failure:"></a>GET:parameters:process:success:failure:</h3><p>初始化方法很好地揭示了 AFNetworking 整个框架的架构，接下来我们要通过分析另一个方法 <code>- GET:parameters:process:success:failure:</code> 的调用栈，看一下 HTTP 请求是如何发出的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- [AFHTTPSessionManager GET:parameters:process:success:failure:]</span><br><span class="line">    - [AFHTTPSessionManager dataTaskWithHTTPMethod:parameters:uploadProgress:downloadProgress:success:failure:] &#x2F;&#x2F; 返回 NSURLSessionDataTask #1</span><br><span class="line">        - [AFHTTPRequestSerializer requestWithMethod:URLString:parameters:error:] &#x2F;&#x2F; 返回 NSMutableURLRequest</span><br><span class="line">        - [AFURLSessionManager dataTaskWithRequest:uploadProgress:downloadProgress:completionHandler:] &#x2F;&#x2F; 返回 NSURLSessionDataTask #2</span><br><span class="line">            - [NSURLSession dataTaskWithRequest:] &#x2F;&#x2F; 返回 NSURLSessionDataTask #3</span><br><span class="line">            - [AFURLSessionManager addDelegateForDataTask:uploadProgress:downloadProgress:completionHandler:]</span><br><span class="line">                - [AFURLSessionManagerTaskDelegate init]</span><br><span class="line">                - [AFURLSessionManager setDelegate:forTask:]</span><br><span class="line">    - [NSURLSessionDataTask resume]</span><br></pre></td></tr></table></figure><p>在这里 <code>#1</code> <code>#2</code> <code>#3</code> 处返回的是同一个 data task，我们可以看到，在 <code>#3</code> 处调用的方法 <code>- [NSURLSession dataTaskWithRequest:]</code> 和只使用 <code>NSURLSession</code> 发出 HTTP 请求时调用的方法 <code>- [NSURLSession dataTaskWithRequest:completionHandler:]</code> 差不多。在这个地方返回 data task 之后，我们再调用 <code>- resume</code> 方法执行请求，并在某些事件执行时通知代理 <code>AFURLSessionManagerTaskDelegate</code>。</p><p>我们在第一篇文章中已经说明过，AFNetworking 3.0 既是在 NSURLSession 之上的高度封装，并提供更加简洁易用的 API。从调用栈的结果来看，将使我们的理解更加清晰。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;首先，我们来看一下 AFNetworking 框架中主要涉及到了哪些类：&lt;/p&gt;
&lt;p&gt;NSURLSession:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AFURLSessionManager&lt;/li&gt;
&lt;li&gt;AFHTTPSessionManager&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;序列化:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AFURLRequestSerialization&lt;/li&gt;
&lt;li&gt;AFURLResponseSerialization&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;附加功能:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AFSecurityPolicy&lt;/li&gt;
&lt;li&gt;AFNetworkReachabilityManager&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>7.AFN2.0与3.0比较</title>
    <link href="http://zxn.wiki/2016/06/10/AFN2-0%E4%B8%8E3-0%E6%AF%94%E8%BE%83(%E4%B8%80)/"/>
    <id>http://zxn.wiki/2016/06/10/AFN2-0%E4%B8%8E3-0%E6%AF%94%E8%BE%83(%E4%B8%80)/</id>
    <published>2016-06-10T12:07:57.000Z</published>
    <updated>2021-06-25T02:55:08.393Z</updated>
    
    <content type="html"><![CDATA[<p>废话不多说,直接上干货</p><p>从 AFNetworking 3.0开始正式支持的iOS 7， Mac OS X的10.9， watchOS 2 ， tvOS 9 和Xcode 7。</p><p>&lt;Excerpt in index | 首页摘要&gt;<br> <a id="more"></a><br>&lt;The rest of contents | 余下全文&gt;</p><h3 id="NSURLConnection的API"><a href="#NSURLConnection的API" class="headerlink" title="NSURLConnection的API"></a>NSURLConnection的API</h3><p>AFNetworking 1.0建立在NSURLConnection的基础API之上 ，AFNetworking 2.0开始使用NSURLConnection的基础API ，以及较新基于NSURLSession的API的选项。 AFNetworking 3.0现已完全基于NSURLSession的API，这降低了维护的负担，同时支持苹果增强关于NSURLSession提供的任何额外功能。由于Xcode 7中，NSURLConnection的API已经正式被苹果弃用。虽然该API将继续运行，但将没有新功能将被添加，并且苹果已经通知所有基于网络的功能，以充分使NSURLSession向前发展。</p><p>AFNetworking 2.X将继续获得关键的隐患和安全补丁，但没有新的功能将被添加。Alamofire(Swift下的网络请求)软件基金会建议，所有的项目迁移到基于NSURLSession的API。</p><h3 id="弃用的类"><a href="#弃用的类" class="headerlink" title="弃用的类"></a>弃用的类</h3><p>下面的类已从AFNetworking 3.0中废弃：</p><ul><li>AFURLConnectionOperation</li><li>AFHTTPRequestOperation</li><li>AFHTTPRequestOperationManager</li></ul><h3 id="修改的类"><a href="#修改的类" class="headerlink" title="修改的类"></a>修改的类</h3><p>下面的类包含基于NSURLConnection的API的内部实现。他们已经被使用NSURLSession重构:</p><ul><li>UIImageView+AFNetworking</li><li>UIWebView+AFNetworking</li><li>UIButton+AFNetworking</li></ul><h3 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h3><hr><h4 id="AFHTTPRequestOperationManager-核心代码"><a href="#AFHTTPRequestOperationManager-核心代码" class="headerlink" title="AFHTTPRequestOperationManager 核心代码"></a>AFHTTPRequestOperationManager 核心代码</h4><p>如果你以前使用 <strong>AFHTTPRequestOperationManager</strong> ， 你将需要迁移去使用 <strong>AFHTTPSessionManager</strong>。 以下的类在两者过渡间并没有变化：</p><ul><li>securityPolicy</li><li>requestSerializer</li><li>responseSerializer</li></ul><p>接下来举一个关于AFHTTPSessionManager的简单例子。注意HTTP网络请求返回的不再是AFHTTPRequestOperation, 修改成为了NSURLSessionTask，并且成功和失败的Block块中的参数也变更为了NSURLSessionTask，而不再是AFHTTPRequestOperation。</p><h3 id="AFNetworking-2-x"><a href="#AFNetworking-2-x" class="headerlink" title="AFNetworking 2.x"></a>AFNetworking 2.x</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AFHTTPRequestOperationManager *manager &#x3D; [AFHTTPRequestOperationManager manager];</span><br><span class="line">[manager GET:@&quot;请求的url&quot; parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) &#123;</span><br><span class="line">        NSLog(@&quot;成功&quot;);</span><br><span class="line">&#125; failure:^(AFHTTPRequestOperation *operation, NSError*error) &#123;</span><br><span class="line">        NSLog(@&quot;失败&quot;);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="AFNetworking-3-0"><a href="#AFNetworking-3-0" class="headerlink" title="AFNetworking 3.0"></a>AFNetworking 3.0</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AFHTTPSessionManager *session &#x3D; [AFHTTPSessionManager manager];</span><br><span class="line">[session GET:@&quot;请求的url&quot; parameters:nil success:^(NSURLSessionDataTask *task, id responseObject) &#123;</span><br><span class="line">        NSLog(@&quot;成功&quot;);</span><br><span class="line">&#125; failure:^(NSURLSessionDataTask *task, NSError *error) &#123;</span><br><span class="line">        NSLog(@&quot;失败&quot;);        </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="AFHTTPRequestOperation-核心代码"><a href="#AFHTTPRequestOperation-核心代码" class="headerlink" title="AFHTTPRequestOperation 核心代码"></a>AFHTTPRequestOperation 核心代码</h3><p>与NSURLConnection对象不同，每个共享应用范围的设置如会话管理、缓存策略、Cookie存储以及URL协议等，这些NSURLSession对象都可以单独进行配置。使用特定的配置来初始化会话，它可以发送任务来获取数据，并上传或下载文件。</p><p>在AFNetworking 2.0中，使用AFHTTPRequestOperation，有可能创建一个没有额外开销的独立的网络请求来获取数据。NSURLSession则需要更多的开销，为了获得所要请求的数据。</p><p>接下来，将要通过AFHTTPSessionManager创建一个对象，并创建一个任务和启动它。</p><h3 id="AFNetworking-2-x-1"><a href="#AFNetworking-2-x-1" class="headerlink" title="AFNetworking 2.x"></a>AFNetworking 2.x</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NSURL *URL &#x3D; [NSURL URLWithString:@&quot;&quot;];</span><br><span class="line">NSURLRequest *request &#x3D; [NSURLRequest requestWithURL:URL];</span><br><span class="line">AFHTTPRequestOperation *op &#x3D; [[AFHTTPRequestOperation alloc] initWithRequest:request];</span><br><span class="line">op.responseSerializer &#x3D; [AFJSONResponseSerializer serializer];</span><br><span class="line">[op setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) &#123;</span><br><span class="line">        NSLog(@&quot;JSON: %@&quot;, responseObject);</span><br><span class="line">&#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123;</span><br><span class="line">        NSLog(@&quot;Error: %@&quot;, error);</span><br><span class="line">&#125;];</span><br><span class="line">[[NSOperationQueue mainQueue] addOperation:op];</span><br></pre></td></tr></table></figure><h3 id="AFNetworking-3-0-1"><a href="#AFNetworking-3-0-1" class="headerlink" title="AFNetworking 3.0"></a>AFNetworking 3.0</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSURL *URL &#x3D; [NSURL URLWithString:@&quot;&quot;];</span><br><span class="line">AFHTTPSessionManager *manager &#x3D; [AFHTTPSessionManager manager];</span><br><span class="line">[manager GET:URL.absoluteString parameters:nil success:^(NSURLSessionTask *task, id responseObject) &#123;</span><br><span class="line">        NSLog(@&quot;JSON: %@&quot;, responseObject);</span><br><span class="line">&#125; failure:^(NSURLSessionTask *operation, NSError *error) &#123;</span><br><span class="line">        NSLog(@&quot;Error: %@&quot;, error);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="UIKit的迁移"><a href="#UIKit的迁移" class="headerlink" title="UIKit的迁移"></a>UIKit的迁移</h3><p>图片下载已经被重构，以遵循AlamofireImage架构与新的AFImageDownloader类。这个类的图片下载职责的代理人是UIButton与UIImageView的类目，并且提供了一些方法，在必要时可以自定义。类别中，下载远程图片的实际方法没有改变。</p><p>UIWebView的类目被重构为使用AFHTTPSessionManager作为其网络请求。</p><h3 id="UIAlertView的类目被废弃"><a href="#UIAlertView的类目被废弃" class="headerlink" title="UIAlertView的类目被废弃"></a>UIAlertView的类目被废弃</h3><p>从AFNetworking 3.0后UIAlertView的类目因过时而被废弃。并没有提供UIAlertController类目的计划，因为这是应用程序应处理的逻辑，而不是这个库。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;废话不多说,直接上干货&lt;/p&gt;
&lt;p&gt;从 AFNetworking 3.0开始正式支持的iOS 7， Mac OS X的10.9， watchOS 2 ， tvOS 9 和Xcode 7。&lt;/p&gt;
&lt;p&gt;&amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>6.NSURLSession的使用</title>
    <link href="http://zxn.wiki/2016/05/27/NSURLSession%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://zxn.wiki/2016/05/27/NSURLSession%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2016-05-27T06:53:48.000Z</published>
    <updated>2021-06-25T02:55:08.395Z</updated>
    
    <content type="html"><![CDATA[<p>NSURLSession 基本使用:</p><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤:"></a>使用步骤:</h3><p>使用NSURLSession创建<code>NSURLSessionTask</code>,然后执行<code>NSURLSessionTask</code>的子类<code>NSURLSessionDataTask</code> \ <code>NSURLSessionUploadTask</code> \ <code>NSURLSessionDownloadTask</code></p><p>&lt;Excerpt in index | 首页摘要&gt;<br> <a id="more"></a><br>&lt;The rest of contents | 余下全文&gt;</p><ul><li>发送第一种<code>get</code>请求<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1.创建NSURLSession对象（可以获取单例对象）</span><br><span class="line">    NSURLSession *session &#x3D; [NSURLSession sharedSession];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;2.根据NSURLSession对象创建一个Task</span><br><span class="line"></span><br><span class="line">    NSURL *url &#x3D; [NSURL URLWithString:@&quot;http:&#x2F;&#x2F;xxxx&#x2F;login?username&#x3D;xxx&amp;pwd&#x3D;xxx&amp;type&#x3D;JSON&quot;];</span><br><span class="line">    NSURLRequest *request &#x3D; [NSURLRequest requestWithURL:url];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;方法参数说明</span><br><span class="line">    &#x2F;*</span><br><span class="line">    注意：该block是在子线程中调用的，如果拿到数据之后要做一些UI刷新操作，那么需要回到主线程刷新</span><br><span class="line">    第一个参数：需要发送的请求对象</span><br><span class="line">    block:当请求结束拿到服务器响应的数据时调用block</span><br><span class="line">    block-NSData:该请求的响应体</span><br><span class="line">    block-NSURLResponse:存放本次请求的响应信息，响应头，真实类型为NSHTTPURLResponse</span><br><span class="line">    block-NSErroe:请求错误信息</span><br><span class="line">     *&#x2F;</span><br><span class="line">   NSURLSessionDataTask * dataTask &#x3D;  [session dataTaskWithRequest:request completionHandler:^(NSData * __nullable data, NSURLResponse * __nullable response, NSError * __nullable error) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;拿到响应头信息</span><br><span class="line">        NSHTTPURLResponse *res &#x3D; (NSHTTPURLResponse *)response;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;4.解析拿到的响应数据</span><br><span class="line">        NSLog(@&quot;%@\n%@&quot;,[[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding],res.allHeaderFields);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;3.执行Task</span><br><span class="line">    &#x2F;&#x2F;注意：刚创建出来的task默认是挂起状态的，需要调用该方法来启动任务（执行任务）</span><br><span class="line">    [dataTask resume];</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>发送第二种<code>get</code>请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;注意：该方法内部默认会把URL对象包装成一个NSURLRequest对象（默认是GET请求）</span><br><span class="line">    &#x2F;&#x2F;方法参数说明</span><br><span class="line">    &#x2F;*</span><br><span class="line">    &#x2F;&#x2F;第一个参数：发送请求的URL地址</span><br><span class="line">    &#x2F;&#x2F;block:当请求结束拿到服务器响应的数据时调用block</span><br><span class="line">    &#x2F;&#x2F;block-NSData:该请求的响应体</span><br><span class="line">    &#x2F;&#x2F;block-NSURLResponse:存放本次请求的响应信息，响应头，真实类型为NSHTTPURLResponse</span><br><span class="line">    &#x2F;&#x2F;block-NSErroe:请求错误信息</span><br><span class="line">     *&#x2F;</span><br><span class="line">- (nullable NSURLSessionDataTask *)dataTaskWithURL:(NSURL *)url completionHandler:(void (^)(NSData * __nullable data, NSURLResponse * __nullable response, NSError * __nullable error))completionHandler;</span><br></pre></td></tr></table></figure></li><li><p>发送post请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1.创建NSURLSession对象（可以获取单例对象）</span><br><span class="line">    NSURLSession *session &#x3D; [NSURLSession sharedSession];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;2.根据NSURLSession对象创建一个Task</span><br><span class="line"></span><br><span class="line">    NSURL *url &#x3D; [NSURL URLWithString:@&quot;http:&#x2F;&#x2F;xxxxx&#x2F;login&quot;];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建一个请求对象，并这是请求方法为POST，把参数放在请求体中传递</span><br><span class="line">    NSMutableURLRequest *request &#x3D; [NSMutableURLRequest requestWithURL:url];</span><br><span class="line">    request.HTTPMethod &#x3D; @&quot;POST&quot;;</span><br><span class="line">    request.HTTPBody &#x3D; [@&quot;username&#x3D;xxx&amp;pwd&#x3D;xxx&amp;type&#x3D;JSON&quot; dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line"></span><br><span class="line">    NSURLSessionDataTask *dataTask &#x3D; [session dataTaskWithRequest:request completionHandler:^(NSData * __nullable data, NSURLResponse * __nullable response, NSError * __nullable error) &#123;</span><br><span class="line">        &#x2F;&#x2F;拿到响应头信息</span><br><span class="line">        NSHTTPURLResponse *res &#x3D; (NSHTTPURLResponse *)response;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;解析拿到的响应数据</span><br><span class="line">        NSLog(@&quot;%@\n%@&quot;,[[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding],res.allHeaderFields);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;3.执行Task</span><br><span class="line">    &#x2F;&#x2F;注意：刚创建出来的task默认是挂起状态的，需要调用该方法来启动任务（执行任务）</span><br><span class="line">    [dataTask resume];</span><br></pre></td></tr></table></figure></li></ul><h3 id="NSURLSession下载文件"><a href="#NSURLSession下载文件" class="headerlink" title="NSURLSession下载文件"></a>NSURLSession下载文件</h3><ol><li>创建NSURLSession对象，设置代理（默认配置）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.创建NSURLSession,并设置代理</span><br><span class="line">&#x2F;*</span><br><span class="line"> 第一个参数：session对象的全局配置设置，一般使用默认配置就可以</span><br><span class="line"> 第二个参数：谁成为session对象的代理</span><br><span class="line"> 第三个参数：代理方法在哪个队列中执行（在哪个线程中调用）,如果是主队列那么在主线程中执行，如果是非主队列，那么在子线程中执行</span><br><span class="line"> *&#x2F;</span><br><span class="line">NSURLSession *session &#x3D; [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[NSOperationQueue mainQueue]];</span><br></pre></td></tr></table></figure><ol start="2"><li>根据Session对象创建一个NSURLSessionDataTask任务（post和get选择）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建task</span><br><span class="line">NSURL *url &#x3D; [NSURL URLWithString:@&quot;http:&#x2F;&#x2F;xxxx&#x2F;img&#x2F;hehe.png&quot;];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注意：如果要发送POST请求，那么请使用dataTaskWithRequest,设置一些请求头信息</span><br><span class="line">NSURLSessionDataTask *dataTask &#x3D; [session dataTaskWithURL:url];</span><br></pre></td></tr></table></figure><ol start="3"><li>执行任务（其它方法，如暂停、取消等）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;启动task</span><br><span class="line">&#x2F;&#x2F;[dataTask resume];</span><br><span class="line">&#x2F;&#x2F;其它方法，如取消任务，暂停任务等</span><br><span class="line">&#x2F;&#x2F;[dataTask cancel];</span><br><span class="line">&#x2F;&#x2F;[dataTask suspend];</span><br></pre></td></tr></table></figure><ol start="4"><li>遵守代理协议，实现代理方法（3个相关的代理方法）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> 1.当接收到服务器响应的时候调用</span><br><span class="line">     session：发送请求的session对象</span><br><span class="line">     dataTask：根据NSURLSession创建的task任务</span><br><span class="line">     response:服务器响应信息（响应头）</span><br><span class="line">     completionHandler：通过该block回调，告诉服务器端是否接收返回的数据</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)URLSession:(nonnull NSURLSession *)session dataTask:(nonnull NSURLSessionDataTask *)dataTask didReceiveResponse:(nonnull NSURLResponse *)response completionHandler:(nonnull void (^)(NSURLSessionResponseDisposition))completionHandler</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> 2.当接收到服务器返回的数据时调用</span><br><span class="line"> 该方法可能会被调用多次</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)URLSession:(nonnull NSURLSession *)session dataTask:(nonnull NSURLSessionDataTask *)dataTask didReceiveData:(nonnull NSData *)data</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> 3.当请求完成之后调用该方法</span><br><span class="line"> 不论是请求成功还是请求失败都调用该方法，如果请求失败，那么error对象有值，否则那么error对象为空</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)URLSession:(nonnull NSURLSession *)session task:(nonnull NSURLSessionTask *)task didCompleteWithError:(nullable NSError *)error</span><br></pre></td></tr></table></figure><ol start="5"><li>当接收到服务器响应的时候，告诉服务器接收数据（调用block）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;默认情况下，当接收到服务器响应之后，服务器认为客户端不需要接收数据，所以后面的代理方法不会调用</span><br><span class="line">    &#x2F;&#x2F;如果需要继续接收服务器返回的数据，那么需要调用block,并传入对应的策略</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">        NSURLSessionResponseCancel &#x3D; 0, 取消任务</span><br><span class="line">        NSURLSessionResponseAllow &#x3D; 1,  接收任务</span><br><span class="line">        NSURLSessionResponseBecomeDownload &#x3D; 2, 转变成下载</span><br><span class="line">        NSURLSessionResponseBecomeStream NS_ENUM_AVAILABLE(10_11, 9_0) &#x3D; 3, 转变成流</span><br><span class="line">    *&#x2F;</span><br><span class="line"></span><br><span class="line">    completionHandler(NSURLSessionResponseAllow);</span><br></pre></td></tr></table></figure></li></ol><h3 id="NSURLSessionDownloadTask-大文件下载"><a href="#NSURLSessionDownloadTask-大文件下载" class="headerlink" title="NSURLSessionDownloadTask 大文件下载"></a>NSURLSessionDownloadTask 大文件下载</h3><ol><li>使用NSURLSession和NSURLSessionDownload可以很方便的实现文件下载操作</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">     第一个参数：要下载文件的url路径</span><br><span class="line">     第二个参数：当接收完服务器返回的数据之后调用该block</span><br><span class="line">     location:下载的文件的保存地址（默认是存储在沙盒中tmp文件夹下面，随时会被删除）</span><br><span class="line">     response：服务器响应信息，响应头</span><br><span class="line">     error：该请求的错误信息</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F;说明：downloadTaskWithURL方法已经实现了在下载文件数据的过程中边下载文件数据，边写入到沙盒文件的操作</span><br><span class="line">    NSURLSessionDownloadTask * downloadTask &#x3D; [session downloadTaskWithURL:url completionHandler:^(NSURL * __nullable location, NSURLResponse * __nullable response, NSError * __nullable error)</span><br></pre></td></tr></table></figure><ol start="2"><li>downloadTaskWithURL内部默认已经实现了变下载边写入操作，所以不用开发人员担心内存问题</li><li>文件下载后默认保存在tmp文件目录，需要开发人员手动的剪切到合适的沙盒目录</li><li>缺点：没有办法监控下载进度</li></ol><h3 id="使用-NSURLSessionDownloadTask-大文件下载-监听下载进度"><a href="#使用-NSURLSessionDownloadTask-大文件下载-监听下载进度" class="headerlink" title="使用 NSURLSessionDownloadTask 大文件下载-监听下载进度"></a>使用 NSURLSessionDownloadTask 大文件下载-监听下载进度</h3><ol><li><p>创建NSURLSession并设置代理，通过NSURLSessionDownloadTask并以代理的方式来完成大文件的下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1.创建NSULRSession,设置代理</span><br><span class="line">    self.session &#x3D; [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[NSOperationQueue mainQueue]];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;2.创建task</span><br><span class="line">    NSURL *url &#x3D; [NSURL URLWithString:@&quot;http:&#x2F;&#x2F;120.25.226.186:32812&#x2F;resources&#x2F;videos&#x2F;minion_01.mp4&quot;];</span><br><span class="line">    self.downloadTask &#x3D; [self.session downloadTaskWithURL:url];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;3.执行task</span><br><span class="line">    [self.downloadTask resume];</span><br></pre></td></tr></table></figure></li><li><p>常用代理方法</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> 1.当接收到下载数据的时候调用,可以在该方法中监听文件下载的进度</span><br><span class="line"> 该方法会被调用多次</span><br><span class="line"> totalBytesWritten:已经写入到文件中的数据大小</span><br><span class="line"> totalBytesExpectedToWrite:目前文件的总大小</span><br><span class="line"> bytesWritten:本次下载的文件数据大小</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)URLSession:(nonnull NSURLSession *)session downloadTask:(nonnull NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite</span><br><span class="line">&#x2F;*</span><br><span class="line"> 2.恢复下载的时候调用该方法</span><br><span class="line"> fileOffset:恢复之后，要从文件的什么地方开发下载</span><br><span class="line"> expectedTotalBytes：该文件数据的总大小</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)URLSession:(nonnull NSURLSession *)session downloadTask:(nonnull NSURLSessionDownloadTask *)downloadTask didResumeAtOffset:(int64_t)fileOffset expectedTotalBytes:(int64_t)expectedTotalBytes</span><br><span class="line">&#x2F;*</span><br><span class="line"> 3.下载完成之后调用该方法</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)URLSession:(nonnull NSURLSession *)session downloadTask:(nonnull NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(nonnull NSURL *)location</span><br><span class="line">&#x2F;*</span><br><span class="line"> 4.请求完成之后调用</span><br><span class="line"> 如果请求失败，那么error有值</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)URLSession:(nonnull NSURLSession *)session task:(nonnull NSURLSessionTask *)task didCompleteWithError:(nullable NSError *)error</span><br></pre></td></tr></table></figure><ol start="3"><li>实现断点下载相关代码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;如果任务，取消了那么以后就不能恢复了</span><br><span class="line">    &#x2F;&#x2F;    [self.downloadTask cancel];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;如果采取这种方式来取消任务，那么该方法会通过resumeData保存当前文件的下载信息</span><br><span class="line">    &#x2F;&#x2F;只要有了这份信息，以后就可以通过这些信息来恢复下载</span><br><span class="line">    [self.downloadTask cancelByProducingResumeData:^(NSData * __nullable resumeData) &#123;</span><br><span class="line">        self.resumeData &#x3D; resumeData;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    -----------</span><br><span class="line">    &#x2F;&#x2F;继续下载</span><br><span class="line">    &#x2F;&#x2F;首先通过之前保存的resumeData信息，创建一个下载任务</span><br><span class="line">    self.downloadTask &#x3D; [self.session downloadTaskWithResumeData:self.resumeData];</span><br><span class="line"></span><br><span class="line">     [self.downloadTask resume];</span><br></pre></td></tr></table></figure><ol start="4"><li><p>计算当前下载进度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获取文件下载进度</span><br><span class="line">    self.progress.progress &#x3D; 1.0 * totalBytesWritten&#x2F;totalBytesExpectedToWrite;</span><br></pre></td></tr></table></figure></li><li><p>局限性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果用户点击暂停之后退出程序，那么需要把恢复下载的数据写一份到沙盒，代码复杂度更</span><br><span class="line">如果用户在下载中途未保存恢复下载数据即退出程序，则不具备可操作性</span><br></pre></td></tr></table></figure></li></ol><h3 id="使用-NSURLSessionDataTask-大文件离线断点下载"><a href="#使用-NSURLSessionDataTask-大文件离线断点下载" class="headerlink" title="使用 NSURLSessionDataTask 大文件离线断点下载"></a>使用 NSURLSessionDataTask 大文件离线断点下载</h3><ol><li><p>关于NSOutputStream的使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1. 创建一个输入流,数据追加到文件的屁股上</span><br><span class="line">    &#x2F;&#x2F;把数据写入到指定的文件地址，如果当前文件不存在，则会自动创建</span><br><span class="line">    NSOutputStream *stream &#x3D; [[NSOutputStream alloc]initWithURL:[NSURL fileURLWithPath:[self fullPath]] append:YES];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;2. 打开流</span><br><span class="line">    [stream open];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;3. 写入流数据</span><br><span class="line">    [stream write:data.bytes maxLength:data.length];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;4.当不需要的时候应该关闭流</span><br><span class="line">    [stream close];</span><br></pre></td></tr></table></figure></li><li><p>关于网络请求请求头的设置（可以设置请求下载文件的某一部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1. 设置请求对象</span><br><span class="line">    &#x2F;&#x2F;1.1 创建请求路径</span><br><span class="line">    NSURL *url &#x3D; [NSURL URLWithString:@&quot;http:&#x2F;&#x2F;120.25.226.186:32812&#x2F;resources&#x2F;videos&#x2F;minion_01.mp4&quot;];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;1.2 创建可变请求对象</span><br><span class="line">    NSMutableURLRequest *request &#x3D; [NSMutableURLRequest requestWithURL:url];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;1.3 拿到当前文件的残留数据大小</span><br><span class="line">    self.currentContentLength &#x3D; [self FileSize];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;1.4 告诉服务器从哪个地方开始下载文件数据</span><br><span class="line">    NSString *range &#x3D; [NSString stringWithFormat:@&quot;bytes&#x3D;%zd-&quot;,self.currentContentLength];</span><br><span class="line">    NSLog(@&quot;%@&quot;,range);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;1.5 设置请求头</span><br><span class="line">    [request setValue:range forHTTPHeaderField:@&quot;Range&quot;];</span><br></pre></td></tr></table></figure></li><li><p>NSURLSession对象的释放</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;在最后的时候应该把session释放，以免造成内存泄露</span><br><span class="line">    &#x2F;&#x2F;    NSURLSession设置过代理后，需要在最后（比如控制器销毁的时候）调用session的invalidateAndCancel或者resetWithCompletionHandler，才不会有内存泄露</span><br><span class="line">    &#x2F;&#x2F;    [self.session invalidateAndCancel];</span><br><span class="line">    [self.session resetWithCompletionHandler:^&#123;</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;释放---&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="NSURLSession-文件上传"><a href="#NSURLSession-文件上传" class="headerlink" title="NSURLSession 文件上传"></a>NSURLSession 文件上传</h3><ol><li><p>实现文件上传的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">     第一个参数：请求对象</span><br><span class="line">     第二个参数：请求体（要上传的文件数据）</span><br><span class="line">     block回调：</span><br><span class="line">     NSData:响应体</span><br><span class="line">     NSURLResponse：响应头</span><br><span class="line">     NSError：请求的错误信息</span><br><span class="line">     *&#x2F;</span><br><span class="line">    NSURLSessionUploadTask *uploadTask &#x3D;  [session uploadTaskWithRequest:request fromData:data completionHandler:^(NSData * __nullable data, NSURLResponse * __nullable response, NSError * __nullable error)</span><br></pre></td></tr></table></figure></li><li><p>设置代理，在代理方法中监听文件上传进度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> 调用该方法上传文件数据</span><br><span class="line"> 如果文件数据很大，那么该方法会被调用多次</span><br><span class="line"> 参数说明：</span><br><span class="line">     totalBytesSent：已经上传的文件数据的大小</span><br><span class="line">     totalBytesExpectedToSend：文件的总大小</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)URLSession:(nonnull NSURLSession *)session task:(nonnull NSURLSessionTask *)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSent totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%.2f&quot;,1.0 * totalBytesSent&#x2F;totalBytesExpectedToSend);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关于NSURLSessionConfiguration相关</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">作用：可以统一配置NSURLSession,如请求超时等</span><br><span class="line">     创建的方式和使用</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建配置的三种方式</span><br><span class="line">+ (NSURLSessionConfiguration *)defaultSessionConfiguration;</span><br><span class="line">+ (NSURLSessionConfiguration *)ephemeralSessionConfiguration;</span><br><span class="line">+ (NSURLSessionConfiguration *)backgroundSessionConfigurationWithIdentifier:(NSString *)identifier NS_AVAILABLE(10_10, 8_0);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;统一配置NSURLSession</span><br><span class="line">- (NSURLSession *)session</span><br><span class="line">&#123;</span><br><span class="line">    if (_session &#x3D;&#x3D; nil) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;创建NSURLSessionConfiguration</span><br><span class="line">        NSURLSessionConfiguration *config &#x3D; [NSURLSessionConfiguration defaultSessionConfiguration];</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;设置请求超时为10秒钟</span><br><span class="line">        config.timeoutIntervalForRequest &#x3D; 10;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;在蜂窝网络情况下是否继续请求（上传或下载）</span><br><span class="line">        config.allowsCellularAccess &#x3D; NO;</span><br><span class="line"></span><br><span class="line">        _session &#x3D; [NSURLSession sessionWithConfiguration:config delegate:self delegateQueue:[NSOperationQueue mainQueue]];</span><br><span class="line">    &#125;</span><br><span class="line">    return _session;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一直在使用中,可一直没总结,借鉴<a href="http://www.jianshu.com/p/04050398c602" target="_blank" rel="noopener">这里</a>.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;NSURLSession 基本使用:&lt;/p&gt;
&lt;h3 id=&quot;使用步骤&quot;&gt;&lt;a href=&quot;#使用步骤&quot; class=&quot;headerlink&quot; title=&quot;使用步骤:&quot;&gt;&lt;/a&gt;使用步骤:&lt;/h3&gt;&lt;p&gt;使用NSURLSession创建&lt;code&gt;NSURLSessionTask&lt;/code&gt;,然后执行&lt;code&gt;NSURLSessionTask&lt;/code&gt;的子类&lt;code&gt;NSURLSessionDataTask&lt;/code&gt; \ &lt;code&gt;NSURLSessionUploadTask&lt;/code&gt; \ &lt;code&gt;NSURLSessionDownloadTask&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>5.NSURLConnection使用</title>
    <link href="http://zxn.wiki/2016/05/17/NSURLConnection%E4%BD%BF%E7%94%A8/"/>
    <id>http://zxn.wiki/2016/05/17/NSURLConnection%E4%BD%BF%E7%94%A8/</id>
    <published>2016-05-17T13:39:40.000Z</published>
    <updated>2021-06-25T02:55:08.395Z</updated>
    
    <content type="html"><![CDATA[<p>NSURLConnection是apple提供的网络请求类.</p><ul><li>作用:<pre><code>1、负责发送请求，建立客户端和服务器的连接发送数据给服务器2、并收集来自服务器的响应数据</code></pre></li></ul><p>&lt;Excerpt in index | 首页摘要&gt;</p><a id="more"></a><p>&lt;The rest of contents | 余下全文&gt;</p><ul><li><p>步骤:</p><pre><code>1、创建一个NSURL对象，设置请求路径2、传入NSURL并创建一个NSURLRequest对象，设置请求头和请求体3、使用NSURLConnection发送请求</code></pre></li><li><p>常见类:</p><pre><code>1、NSURL:收纳请求的地址2、NSURLRequest:一个NSURLRequest对象就代表一个请求，它包含的信息有一个NSURL对象、请求方法、请求头、请求体等等3、NSMutableURLRequest是NSURLRequest的子类</code></pre></li><li><p>发送同步请求:(不建议使用)</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (void)sendSynchronousRequest&#123;</span><br><span class="line">  &#x2F;&#x2F;1、创建一个URL</span><br><span class="line">  &#x2F;&#x2F;协议头+主机地址+接口名称+?+参数1&amp;参数2&amp;参数3</span><br><span class="line">  NSURL *url &#x3D; [NSURL URLWithString:@&quot;http:&#x2F;&#x2F;xxxxx&#x2F;login&quot;];</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;2、创建请求(Request)对象(默认为GET请求)；</span><br><span class="line">  NSURLRequest *requst &#x3D; [[NSURLRequest alloc]initWithURL:url];</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;3、发送请求</span><br><span class="line">  &#x2F;*</span><br><span class="line">   第一个参数:请求对象</span><br><span class="line">   第二个参数:响应头</span><br><span class="line">   第三个参数:错误信息</span><br><span class="line">   返回值:NSData类型,响应体信息</span><br><span class="line">   *&#x2F;</span><br><span class="line">  NSError *error &#x3D; nil;</span><br><span class="line">  NSURLResponse *response &#x3D; nil;</span><br><span class="line">  &#x2F;&#x2F;发送同步请求(sendSynchronousRequest)</span><br><span class="line">  NSData *data &#x3D; [NSURLConnection sendSynchronousRequest:requst returningResponse:&amp;response error:&amp;error];</span><br><span class="line">  &#x2F;&#x2F;如果没有错误就执行</span><br><span class="line">  if (!error) &#123;</span><br><span class="line">      &#x2F;&#x2F;打印的服务端返回的信息以及错误信息</span><br><span class="line">      NSLog(@&quot;%@&quot;,[[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding]);</span><br><span class="line">      NSLog(@&quot;%@&quot;,error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>发送异步请求:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">-(void)sendAsynchronousRequest&#123;</span><br><span class="line">        &#x2F;&#x2F;1、创建一个URL</span><br><span class="line">        NSURL *url &#x3D; [NSURL URLWithString:@&quot;http:&#x2F;&#x2F;xxxxx&#x2F;login&quot;];</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;2、创建请求(Request)对象 这里使用的是它的子类NSMutableURLRequest,因为子类才具有设置方法和设置请求体的属性</span><br><span class="line">        NSMutableURLRequest *requst &#x3D; [[NSMutableURLRequest alloc]initWithURL:url];</span><br><span class="line">        &#x2F;&#x2F;2.1、设置请求方法</span><br><span class="line">        requst.HTTPMethod &#x3D; @&quot;POST&quot;;</span><br><span class="line">        &#x2F;&#x2F;2.2、设置请求体,因为传入的为Data数据所有这里需要转换</span><br><span class="line">        requst.HTTPBody &#x3D; [@&quot;username&#x3D;xxx&amp;pwd&#x3D;xxx&quot; dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">        &#x2F;&#x2F;2.3、设置请求超时时间，如果超过这个时间，请求为失败</span><br><span class="line">        requst.timeoutInterval &#x3D; 10;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;3、发送请求</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">         第一个参数:请求对象</span><br><span class="line">         第二个参数:队列</span><br><span class="line">         第三个参数:Block回调函数</span><br><span class="line">            response:响应头</span><br><span class="line">            data:响应体信息</span><br><span class="line">            connectionError:错误信息</span><br><span class="line">         *&#x2F;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;发送异步请求(sendAsynchronousRequest)</span><br><span class="line">        [NSURLConnection sendAsynchronousRequest:requst queue:[[NSOperationQueue alloc]init] completionHandler:^(NSURLResponse * _Nullable response, NSData * _Nullable data, NSError * _Nullable connectionError) &#123;</span><br><span class="line">            NSLog(@&quot;----%@&quot;,[NSThread currentThread]);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;解析数据</span><br><span class="line">            NSLog(@&quot;%@&quot;,[[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding]);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>代理请求:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、当接受到服务器响应的时候会调用:response(响应头)</span><br><span class="line">    -(void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response;</span><br><span class="line">2、当接受到服务器返回数据的时候调用(会调用多次)</span><br><span class="line">    - (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data;</span><br><span class="line">3、当请求失败的时候调用</span><br><span class="line">    - (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error;</span><br><span class="line">4、当请求结束(成功|失败)的时候调用</span><br><span class="line">    - (void)connectionDidFinishLoading:(NSURLConnection *)connection;</span><br></pre></td></tr></table></figure></li></ul><p>具体代码如下 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">1、首先实现代理,并定义一个NSData对象初始化,在请求结束的时候查看服务器传来的内容，</span><br><span class="line">    @interface ViewController ()&lt;NSURLConnectionDataDelegate&gt;</span><br><span class="line">    &#x2F;** 可变的二进制数据 *&#x2F;</span><br><span class="line">    @property (nonatomic, strong) NSMutableData *fileData;</span><br><span class="line">    @end</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">    懒加载</span><br><span class="line">    *&#x2F;</span><br><span class="line">    -(NSMutableData *)fileData&#123;</span><br><span class="line">        if (!_fileData) &#123;</span><br><span class="line">            _fileData &#x3D; [[NSMutableData alloc]init];</span><br><span class="line">        &#125;</span><br><span class="line">        return _fileData;</span><br><span class="line">    &#125;</span><br><span class="line">2、实现代理中的四个方法</span><br><span class="line">    &#x2F;&#x2F;1.当接受到服务器响应的时候会调用:response(响应头)</span><br><span class="line">    -(void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response</span><br><span class="line">    &#123;</span><br><span class="line">        NSLog(@&quot;接受到相应&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;2.当接受到服务器返回数据的时候调用(会调用多次)</span><br><span class="line">    -(void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;</span><br><span class="line">        NSLog(@&quot;接受到数据&quot;);</span><br><span class="line">        &#x2F;&#x2F;拼接数据</span><br><span class="line">        [self.fileData appendData:data];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;3.当请求失败的时候调用</span><br><span class="line">    -(void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error</span><br><span class="line">    &#123;</span><br><span class="line">        NSLog(@&quot;请求失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;4.当请求结束(成功|失败)的时候调用</span><br><span class="line">    -(void)connectionDidFinishLoading:(NSURLConnection *)connection</span><br><span class="line">    &#123;</span><br><span class="line">        NSLog(@&quot;请求结束&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;解析数据</span><br><span class="line">        NSLog(@&quot;%@&quot;,[[NSString alloc]initWithData:self.fileData encoding:NSUTF8StringEncoding]);</span><br><span class="line">    &#125;</span><br><span class="line">3、最后编写点击时调用的方法</span><br><span class="line">    -(void)sendRequestWithDelegate&#123;</span><br><span class="line">        &#x2F;&#x2F;1.确定请求路径</span><br><span class="line">        NSURL *url &#x3D; [NSURL URLWithString:@&quot;http:&#x2F;&#x2F;xxxxx&#x2F;login?username&#x3D;xxx&amp;pwd&#x3D;xxx&quot;];</span><br><span class="line">        &#x2F;&#x2F;2.创建请求对象</span><br><span class="line">        NSURLRequest *request &#x3D; [NSURLRequest requestWithURL:url];</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;3、代理请求</span><br><span class="line">        &#x2F;*</span><br><span class="line">         第一个参数:请求对象</span><br><span class="line">         第二个参数:谁成为代理</span><br><span class="line">         第三个参数:startImmediately :是否立即开始发送网络请求</span><br><span class="line">         *&#x2F;</span><br><span class="line">        NSURLConnection *connect &#x3D; [[NSURLConnection alloc]initWithRequest:request delegate:self startImmediately:NO];</span><br><span class="line">        &#x2F;&#x2F;[connect cancel]; 取消</span><br><span class="line">        [connect start];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;NSURLConnection是apple提供的网络请求类.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作用:&lt;pre&gt;&lt;code&gt;1、负责发送请求，建立客户端和服务器的连接发送数据给服务器
2、并收集来自服务器的响应数据&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>总结的OC代码规范</title>
    <link href="http://zxn.wiki/2016/05/10/%E6%80%BB%E7%BB%93%E7%9A%84OC%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>http://zxn.wiki/2016/05/10/%E6%80%BB%E7%BB%93%E7%9A%84OC%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</id>
    <published>2016-05-10T03:47:55.000Z</published>
    <updated>2021-06-25T02:55:08.397Z</updated>
    
    <content type="html"><![CDATA[<h3 id="命名"><a href="#命名" class="headerlink" title="命名:"></a>命名:</h3><ul><li>驼峰命名法:</li></ul><p>所有的单词首字母大写和加上与类名有关的前缀,例如:<code>MyRootViewControllerNavigationAnimationDuration</code></p><p>&lt;Excerpt in index | 首页摘要&gt;<br> <a id="more"></a><br>&lt;The rest of contents | 余下全文&gt;</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释:"></a>注释:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** ---- *&#x2F;  格式</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">  *</span><br><span class="line">  *&#x2F;      格式</span><br></pre></td></tr></table></figure><p>并且标明此段代码的意思以及用处</p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块:"></a>代码块:</h3><p>不同业务代码和protocol/delegate实现中使用<code>#pragma mark -</code> 来分类方法</p><p><code>#pragma mark - UITableView Delegate</code></p><h3 id="方法空格"><a href="#方法空格" class="headerlink" title="方法空格:"></a>方法空格:</h3><ul><li>在方法 (-/+) 后面 有一个空格</li><li>在方法各个参数段之间有一个空格</li></ul><h3 id="变量名称"><a href="#变量名称" class="headerlink" title="变量名称:"></a>变量名称:</h3><p>变量尽量以描述性的方式来命名。单个字符的变量命名应该尽量避免，除了在<code>for()</code>循环。</p><h3 id="属性特性"><a href="#属性特性" class="headerlink" title="属性特性:"></a>属性特性:</h3><p>所有属性特性应该显式地列出来,例如 strong / weak / copy / readonly / readwrite</p><h3 id="点语法"><a href="#点语法" class="headerlink" title="点语法:"></a>点语法:</h3><p>点语法是一种很方便封装访问方法调用的方式。当你使用点语法时，通过使用getter或setter方法，属性仍然被访问或修改.<br>点语法应该总是被用来访问和修改属性，因为它使代码更加简洁</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量:"></a>常量:</h3><p>常量是容易重复被使用和无需通过查找和代替就能快速修改值。常量应该使用<code>static</code>来声明而不是使用<code>#define</code>，除非显式地使用宏.</p><h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型:"></a>枚举类型:</h3><p>当使用enum时，推荐使用宏<code>NS_ENUM()</code>和<code>NS_OPTIONS</code></p><ul><li>NS_OPTIONS<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, UISwipeGestureRecognizerDirection) &#123;</span><br><span class="line">    UISwipeGestureRecognizerDirectionNone &#x3D; 0,  &#x2F;&#x2F;值为0</span><br><span class="line">    UISwipeGestureRecognizerDirectionRight &#x3D; 1 &lt;&lt; 0,  &#x2F;&#x2F;值为2的0次方</span><br><span class="line">    UISwipeGestureRecognizerDirectionLeft &#x3D; 1 &lt;&lt; 1,  &#x2F;&#x2F;值为2的1次方</span><br><span class="line">    UISwipeGestureRecognizerDirectionUp &#x3D; 1 &lt;&lt; 2,  &#x2F;&#x2F;值为2的2次方</span><br><span class="line">    UISwipeGestureRecognizerDirectionDown &#x3D; 1 &lt;&lt; 3  &#x2F;&#x2F;值为2的3次方</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>NS_ENUM<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, NSWritingDirection) &#123;</span><br><span class="line">    NSWritingDirectionNatural &#x3D; -1,  &#x2F;&#x2F;值为-1    </span><br><span class="line">    NSWritingDirectionLeftToRight &#x3D; 0,  &#x2F;&#x2F;值为0</span><br><span class="line">    NSWritingDirectionRightToLeft &#x3D; 1  &#x2F;&#x2F;值为1       </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>NS_ENUM与NS_OPTIONS区别:</li><li><code>NS_ENUM</code>枚举项的值为<code>NSInteger</code>，<code>NS_OPTIONS</code>枚举项的值为<code>NSUInteger</code>；</li><li><code>NS_ENUM</code>定义通用枚举，<code>NS_OPTIONS</code>定义位移枚举</li></ul><p>位移枚举即是在你需要的地方可以同时存在多个枚举值,而NS_ENUM定义的枚举不能几个枚举项同时存在，只能选择其中一项</p><h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值:"></a>布尔值:</h3><p>Objective-C使用<code>YES</code>和<code>NO</code>,不用<code>true</code>和<code>false</code>,<br>因为true和false应该只在CoreFoundation，C或C++代码使用。</p><h3 id="三元操作符-三目运算符"><a href="#三元操作符-三目运算符" class="headerlink" title="三元操作符/三目运算符:"></a>三元操作符/三目运算符:</h3><p>当需要提高代码的清晰性和简洁性时，三元操作符<code>?:</code>才会使用。单个条件求值常常需要它。多个条件求值时，如果使用<code>if</code>语句或重构成实例变量时，代码会更加易读。一般来说，最好使用三元操作符是在根据条件来赋值的情况下。</p><h3 id="Init方法"><a href="#Init方法" class="headerlink" title="Init方法:"></a>Init方法:</h3><p>Init方法应该遵循Apple生成代码模板的命名规则。返回类型应该使用<code>instancetype</code>而不是<code>id</code></p><h3 id="类构造方法"><a href="#类构造方法" class="headerlink" title="类构造方法:"></a>类构造方法:</h3><p>当类构造方法被使用时，它应该返回类型是<code>instancetype</code>而不是<code>id</code></p><h3 id="CGRect函数"><a href="#CGRect函数" class="headerlink" title="CGRect函数:"></a>CGRect函数:</h3><p>当访问CGRect里的x, y, width, 或 height时,使用<code>CGRectMake</code>, 不要使用 (CGRect){}</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式:"></a>单例模式:</h3><p>单例对象应该使用线程安全模式来创建共享实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)sharedInstance &#123;</span><br><span class="line">  static id sharedInstance &#x3D; nil;</span><br><span class="line"></span><br><span class="line">  static dispatch_once_t onceToken;</span><br><span class="line">  dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">    sharedInstance &#x3D; [[self alloc] init];</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return sharedInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;命名&quot;&gt;&lt;a href=&quot;#命名&quot; class=&quot;headerlink&quot; title=&quot;命名:&quot;&gt;&lt;/a&gt;命名:&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;驼峰命名法:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有的单词首字母大写和加上与类名有关的前缀,例如:&lt;code&gt;MyRootViewControllerNavigationAnimationDuration&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Hexo主题设置</title>
    <link href="http://zxn.wiki/2016/05/06/Hexo%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE/"/>
    <id>http://zxn.wiki/2016/05/06/Hexo%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE/</id>
    <published>2016-05-06T13:08:23.000Z</published>
    <updated>2021-06-25T02:55:08.394Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo 支持个性化定制主题，可以根据自己的喜好进行修改，想获取更多主题点击<a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="noopener">这里</a>哦</p><p>&lt;Excerpt in index | 首页摘要&gt;<br> <a id="more"></a><br>&lt;The rest of contents | 余下全文&gt;</p><h3 id="一、安装主题"><a href="#一、安装主题" class="headerlink" title="一、安装主题"></a>一、安装主题</h3><p>目前使用的主题是：<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">yilia</a></p><h3 id="克隆主题"><a href="#克隆主题" class="headerlink" title="克隆主题"></a>克隆主题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;litten&#x2F;hexo-theme-yilia.git themes&#x2F;yilia</span><br></pre></td></tr></table></figure><h3 id="执行："><a href="#执行：" class="headerlink" title="执行："></a>执行：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim _config.yml</span><br></pre></td></tr></table></figure><h3 id="将-theme-对应的值进行修改"><a href="#将-theme-对应的值进行修改" class="headerlink" title="将 theme 对应的值进行修改"></a>将 theme 对应的值进行修改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: yilia</span><br></pre></td></tr></table></figure><h3 id="接着就自动部署一下："><a href="#接着就自动部署一下：" class="headerlink" title="接着就自动部署一下："></a>接着就自动部署一下：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h3 id="最后发布："><a href="#最后发布：" class="headerlink" title="最后发布："></a>最后发布：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><p>稍等片刻看一下自己的博客主页，你想要的效果就出现了。也可以点击<a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="noopener">更多</a>，挑选自己喜欢的主题进行修改，只要你快乐就好</p><h3 id="二、主题配置"><a href="#二、主题配置" class="headerlink" title="二、主题配置"></a>二、主题配置</h3><h4 id="进入到根目录下的-themes-yilia-文件夹，执行"><a href="#进入到根目录下的-themes-yilia-文件夹，执行" class="headerlink" title="进入到根目录下的 themes\yilia 文件夹，执行"></a>进入到根目录下的 themes\yilia 文件夹，执行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim _config.yml</span><br></pre></td></tr></table></figure><p>头像可以设置  <code>avatar</code>  信息,配置文件中都有注释,但是记得冒号后需要加个 <code>空格</code></p><h4 id="配置完成后执行"><a href="#配置完成后执行" class="headerlink" title="配置完成后执行"></a>配置完成后执行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><p>开心玩耍吧~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Hexo 支持个性化定制主题，可以根据自己的喜好进行修改，想获取更多主题点击&lt;a href=&quot;https://github.com/hexojs/hexo/wiki/Themes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;哦&lt;/p&gt;
&lt;p&gt;&amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>搭建个人博客</title>
    <link href="http://zxn.wiki/2016/05/03/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://zxn.wiki/2016/05/03/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2016-05-03T15:17:31.000Z</published>
    <updated>2021-06-25T02:55:08.397Z</updated>
    
    <content type="html"><![CDATA[<p>前言:<br>想搭建自己的个人博客又不懂技术,怎么办? 没关系,我踩坑!慢慢教你怎么搭建个人博客 (持续更新中…)  </p><p>设备: MacBook Pro<br>系统: OS X EI Capitan 10.11.3</p><p>&lt;Excerpt in index | 首页摘要&gt;<br> <a id="more"></a><br>&lt;The rest of contents | 余下全文&gt;</p><p>当然我在搭建博客之前也是查看了好多资料,并且在搭建的时候踩了很多坑<br>下面跟我一起行动起来!</p><p>准备条件:<br>一. 了解Github 和 Github Page Hexo<br>二. 注册Github 账号 配置Git<br>三. 安装brewhome Node.js Hexo</p><p>一. Github &amp; Github Page &amp; Hexo:<br>GitHub: 是一个利用Git进行版本控制、专门用于存放软件代码与内容的共享虚拟主机服务. 很啰嗦是不,那你就记住 它是专门放东西的一个仓库就OK<br>Github Page: 它本用于介绍托管在GitHub的项目,但是有一个免费稳定的空间,一般用于编写博客,也可以认为是用户编写的、托管在github上的静态网页<br>Hexo 是一个快速、简单且功能强大的 Node.js 博客框架.</p><p>二. 注册Github 账号</p><ol><li>需要先到 <a href="https://github.com/" target="_blank" rel="noopener">官网</a> 注册一个自己的github账号 (主要是 username 和 useremail了)</li><li>配置本地git配置:<ol><li>git config –global user.name</li><li>git config –global user.email</li></ol></li><li>需要mac 和 github 做认证 链接</li><li>根据第3步的教程 创建一个username.github.io的项目</li></ol><p>三. Hexo</p><ol><li><p>简介</p><p> hexo是由 <a href="https://github.com/hexojs" target="_blank" rel="noopener">hexo</a> 团队编程开发, 是一个基于Node.js的静态博客程序,hexo生成的静态网页可以直接放到GitHub Pages，BAE，SAE等平台上!</p></li><li><p>安装</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 安装 brewhome </span><br><span class="line">terminal 中输入 &quot;ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.github.com&#x2F;Homebrew&#x2F;homebrew&#x2F;go&#x2F;install)” 回车</span><br><span class="line">2. 安装 node </span><br><span class="line">brew install node</span><br><span class="line">3. 安装 hexo </span><br><span class="line">在终端cd到你建立的文件夹名称下</span><br><span class="line">$  sudo npm install -g hexo</span><br><span class="line">(输入密码 命令行输入密码实际是输入的只是你看不见而已 输完密码敲回车)</span><br><span class="line">$  hexo init&lt;folder&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>会生成如下结构的文件：</p><blockquote><p> .<br> ├── _config.yml 站点配置文件<br> ├── package.json 站点依赖文件<br> ├── scaffolds 模板文件夹<br> ├── source 资源文件夹<br> ├── _drafts<br> ├── _posts<br> ├── themes 主题文件夹</p></blockquote><p>最后一步你npm install不可少，它主要功能是用于安装package.json中的依赖，当有改动package.json中的依赖时都要运行一次<br>到此hexo安装就算完成了，然后在命令行运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo sever</span><br></pre></td></tr></table></figure><p>就可以看到hexo默认主题效果了</p><ol start="3"><li>hexo常用命令</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo init [folder] 新建一个网站</span><br><span class="line">hexo new [layout] &lt;title&gt; 创建一篇新文章</span><br><span class="line">hexo sever或hexo s 启动服务器</span><br><span class="line">hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)</span><br><span class="line">hexo generate或hexo g 生成静态文件</span><br><span class="line">hexo deploy或hexo d 部署网站</span><br><span class="line">hexo migrate &lt;type&gt; 从其他博客系统迁移内容</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;前言:&lt;br&gt;想搭建自己的个人博客又不懂技术,怎么办? 没关系,我踩坑!慢慢教你怎么搭建个人博客 (持续更新中…)  &lt;/p&gt;
&lt;p&gt;设备: MacBook Pro&lt;br&gt;系统: OS X EI Capitan 10.11.3&lt;/p&gt;
&lt;p&gt;&amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>搭建个人博客</title>
    <link href="http://zxn.wiki/2016/05/03/hello-world/"/>
    <id>http://zxn.wiki/2016/05/03/hello-world/</id>
    <published>2016-05-03T13:06:27.000Z</published>
    <updated>2021-06-25T02:55:08.396Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.</summary>
      
    
    
    
    
  </entry>
  
</feed>
