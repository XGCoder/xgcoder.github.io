<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhaoxioaga.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="AFURLSessionManager 绝对可以称得上是 AFNetworking 的核心,在这里再一次地进行解析 &lt;Excerpt in index | 首页摘要&gt;">
<meta property="og:type" content="article">
<meta property="og:title" content="9-AFN2-0与3-0比较(三)">
<meta property="og:url" content="http://zhaoxioaga.github.io/2016/06/17/AFN2-0%E4%B8%8E3-0%E6%AF%94%E8%BE%83(%E4%B8%89)/index.html">
<meta property="og:site_name" content="XG">
<meta property="og:description" content="AFURLSessionManager 绝对可以称得上是 AFNetworking 的核心,在这里再一次地进行解析 &lt;Excerpt in index | 首页摘要&gt;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://zhaoxioaga.github.io/img/NSURLSessionDelegate.png">
<meta property="article:published_time" content="2016-06-17T12:49:51.000Z">
<meta property="article:modified_time" content="2021-06-21T09:30:36.391Z">
<meta property="article:author" content="赵小嘎">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://zhaoxioaga.github.io/img/NSURLSessionDelegate.png">

<link rel="canonical" href="http://zhaoxioaga.github.io/2016/06/17/AFN2-0%E4%B8%8E3-0%E6%AF%94%E8%BE%83(%E4%B8%89)/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>9-AFN2-0与3-0比较(三) | XG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">XG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zhaoxioaga.github.io/2016/06/17/AFN2-0%E4%B8%8E3-0%E6%AF%94%E8%BE%83(%E4%B8%89)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="赵小嘎">
      <meta itemprop="description" content="赵小嘎在 Github 上的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          9-AFN2-0与3-0比较(三)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-06-17 20:49:51" itemprop="dateCreated datePublished" datetime="2016-06-17T20:49:51+08:00">2016-06-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-21 17:30:36" itemprop="dateModified" datetime="2021-06-21T17:30:36+08:00">2021-06-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><code>AFURLSessionManager</code> 绝对可以称得上是 AFNetworking 的核心,在这里再一次地进行解析</p>
<p>&lt;Excerpt in index | 首页摘要&gt;<br> <a id="more"></a><br>&lt;The rest of contents | 余下全文&gt;</p>
<h3 id="AFURLSessionManager"><a href="#AFURLSessionManager" class="headerlink" title="AFURLSessionManager"></a>AFURLSessionManager</h3><p>首先，在 <code>AFURLSessionManager.h</code> 中关于 <code>AFURLSessionManager</code> 的概述：</p>
<ul>
<li>负责创建和管理 NSURLSession</li>
<li>管理 NSURLSessionTask</li>
<li>实现 NSURLSessionDelegate 等协议中的代理方法</li>
<li>使用 AFURLSessionManagerTaskDelegate 管理进度</li>
<li>使用 AFURLSessionTaskSwizzling 调剂方法</li>
<li>引入 AFSecurityPolicy 保证请求的安全</li>
<li>引入 AFNetworkReachabilityManager 监控网络状态</li>
</ul>
<h3 id="创建和管理-NSURLSession"><a href="#创建和管理-NSURLSession" class="headerlink" title="创建和管理 NSURLSession"></a>创建和管理 <code>NSURLSession</code></h3><p>按惯例，我们由 <code>AFURLSessionManager</code> 的初始化方法：<code>- (instancetype)initWithSessionConfiguration:(nullable NSURLSessionConfiguration *)configuration NS_DESIGNATED_INITIALIZER;</code> 进行展开：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration &#123;</span><br><span class="line">    self &#x3D; [super init];</span><br><span class="line">    if (!self) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!configuration) &#123;</span><br><span class="line">        configuration &#x3D; [NSURLSessionConfiguration defaultSessionConfiguration];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self.sessionConfiguration &#x3D; configuration;</span><br><span class="line"></span><br><span class="line">    self.operationQueue &#x3D; [[NSOperationQueue alloc] init];</span><br><span class="line">    self.operationQueue.maxConcurrentOperationCount &#x3D; 1;</span><br><span class="line"></span><br><span class="line">    self.session &#x3D; [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue];</span><br><span class="line"></span><br><span class="line">    self.responseSerializer &#x3D; [AFJSONResponseSerializer serializer];</span><br><span class="line"></span><br><span class="line">    self.securityPolicy &#x3D; [AFSecurityPolicy defaultPolicy];</span><br><span class="line"></span><br><span class="line">#if !TARGET_OS_WATCH</span><br><span class="line">    self.reachabilityManager &#x3D; [AFNetworkReachabilityManager sharedManager];</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    self.mutableTaskDelegatesKeyedByTaskIdentifier &#x3D; [[NSMutableDictionary alloc] init];</span><br><span class="line"></span><br><span class="line">    self.lock &#x3D; [[NSLock alloc] init];</span><br><span class="line">    self.lock.name &#x3D; AFURLSessionManagerLockName;</span><br><span class="line"></span><br><span class="line">    [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) &#123;</span><br><span class="line">        for (NSURLSessionDataTask *task in dataTasks) &#123;</span><br><span class="line">            [self addDelegateForDataTask:task uploadProgress:nil downloadProgress:nil completionHandler:nil];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (NSURLSessionUploadTask *uploadTask in uploadTasks) &#123;</span><br><span class="line">            [self addDelegateForUploadTask:uploadTask progress:nil completionHandler:nil];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (NSURLSessionDownloadTask *downloadTask in downloadTasks) &#123;</span><br><span class="line">            [self addDelegateForDownloadTask:downloadTask progress:nil destination:nil completionHandler:nil];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法主要完成如下工作：</p>
<pre><code>1 . 初始化 **会话配置**（NSURLSessionConfiguration），默认为 `defaultSessionConfiguration`
2 . 设置相应的 `OperationQueue`，决定请求过程中的一系列事件在哪个 `OperationQueue` 回调，这里是设置了最大并发量为 1 的队列，也就相当于串行队列了。(AFNetworing 2.0 版本是设置了一条常驻线程来响应所有网络请求的 delegate 事件)
3 . 初始化会话（session），并设置会话的代理及代理队列，delegate 用来处理请求中的各种事件，可以设置为 nil 使用系统提供的 delegate，但是要想支持后台传输数据必须提供自定义实现的 delegate；另外，`NSURLSession` 对象是强引用了 delegate，如果程序最终没有调用 `invalidateAndCancel` 方法来 invalidate 该 session 的话，则会造成内存泄漏
4 . 初始化管理 **响应序列化**（AFJSONResponseSerializer），**安全认证**（AFSecurityPolicy）以及 **监控网络状态**（AFNetworkReachabilityManager）的实例
5 . 初始化保存 data task 的字典（mutableTaskDelegatesKeyedByTaskIdentifier）</code></pre><h3 id="管理-NSURLSessionTask"><a href="#管理-NSURLSessionTask" class="headerlink" title="管理 NSURLSessionTask"></a>管理 <code>NSURLSessionTask</code></h3><p>接下来，在获得了 <code>AFURLSessionManager</code> 的实例之后，我们可以通过以下方法创建 <code>NSURLSessionDataTask</code> 的实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> Creates an &#96;NSURLSessionDataTask&#96; with the specified request.</span><br><span class="line"></span><br><span class="line"> @param request The HTTP request for the request.</span><br><span class="line"> @param completionHandler A block object to be executed when the task finishes. This block has no return value and takes three arguments: the server response, the response object created by that serializer, and the error that occurred, if any.</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request</span><br><span class="line">                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</span><br><span class="line">                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</span><br><span class="line">                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这里省略了一些返回 <code>NSURLSessionTask</code> 的方法，因为这些接口的形式都是差不多的。</p>
<p>下面，我们将以 <code>- [AFURLSessionManager dataTaskWithRequest:uploadProgress:downloadProgress:completionHandler:]</code> 方法的实现为例，分析它是如何实例化并返回一个 <code>NSURLSessionTask</code> 的实例的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request</span><br><span class="line">                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</span><br><span class="line">                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</span><br><span class="line">                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler &#123;</span><br><span class="line"></span><br><span class="line">    __block NSURLSessionDataTask *dataTask &#x3D; nil;</span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        dataTask &#x3D; [self.session dataTaskWithRequest:request];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line">    return dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法主要完成如下工作：</p>
<ul>
<li>调用 <code>- [NSURLSession dataTaskWithRequest:]</code> 方法传入 <code>NSURLRequest</code></li>
<li>调用 <code>- [AFURLSessionManager addDelegateForDataTask:uploadProgress:downloadProgress:completionHandler:] 方法返回一个 AFURLSessionManagerTaskDelegate</code> 对象</li>
<li>将 <code>completionHandler uploadProgressBlock</code> 和 <code>downloadProgressBlock</code> 传入该对象并在相应事件发生时进行回调</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">                uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</span><br><span class="line">              downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</span><br><span class="line">             completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate &#x3D; [[AFURLSessionManagerTaskDelegate alloc] init];</span><br><span class="line">    delegate.manager &#x3D; self;</span><br><span class="line">    delegate.completionHandler &#x3D; completionHandler;</span><br><span class="line"></span><br><span class="line">    dataTask.taskDescription &#x3D; self.taskDescriptionForSessionTasks;</span><br><span class="line">    [self setDelegate:delegate forTask:dataTask];</span><br><span class="line"></span><br><span class="line">    delegate.uploadProgressBlock &#x3D; uploadProgressBlock;</span><br><span class="line">    delegate.downloadProgressBlock &#x3D; downloadProgressBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法中同时调用了另一个方法 <code>- [AFURLSessionManager setDelegate:forTask:]</code> 来设置代理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</span><br><span class="line">            forTask:(NSURLSessionTask *)task</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    #1: 检查参数, 略</span><br><span class="line"></span><br><span class="line">    [self.lock lock];</span><br><span class="line">    self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] &#x3D; delegate;</span><br><span class="line">    [delegate setupProgressForTask:task];</span><br><span class="line">    [self addNotificationObserverForTask:task];</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正如上面所提到的，<code>AFURLSessionManager</code> 就是通过字典 <code>mutableTaskDelegatesKeyedByTaskIdentifier</code> 来存储并管理每一个 <code>NSURLSessionTask</code>，它以 <code>taskIdentifier</code> 为键存储 <code>task</code>。</p>
<p>该方法使用 NSLock 来保证不同线程使用 <code>mutableTaskDelegatesKeyedByTaskIdentifier</code> 时，不会出现线程竞争的问题（既线程同步）。</p>
<p>同时调用 <code>- setupProgressForTask:</code>，我们会在下面具体介绍这个方法。</p>
<h3 id="实现-NSURLSessionDelegate-等协议中的代理方法"><a href="#实现-NSURLSessionDelegate-等协议中的代理方法" class="headerlink" title="实现 NSURLSessionDelegate 等协议中的代理方法"></a>实现 <code>NSURLSessionDelegate</code> 等协议中的代理方法</h3><p>首先查看NSURLSessionDelegate的结构:<br><img src="/img/NSURLSessionDelegate.png" alt=""></p>
<p>接下来，我们来看下具体的代理方法：</p>
<ul>
<li><code>NSURLSessionDelegate</code></li>
<li><code>NSURLSessionTaskDelegate</code>，遵守 <code>NSURLSessionDelegate</code> 协议</li>
<li><code>NSURLSessionDataDelegate</code>，遵守 <code>NSURLSessionTaskDelegate</code> 协议，是网络请求通常遵循的协议，常用的方法：</li>
</ul>
<pre><code>1 . 接受到服务响应时调用的方法</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 必须在该方法中对服务器的响应进行授权，才能继续接收服务器返回的数据，调用如下函数</span><br><span class="line">* completionHandler（NSURLSessionResponseAllow）</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>

<p>  2 . 接收到服务器返回的数据时调用的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data</span><br><span class="line">&#x2F;**</span><br><span class="line">* data：服务返回的数据，通常为 JSON 格式数据</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>

<p>  3 . 请求完成时调用的方法（成功或失败）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(nullable NSError *)error</span><br><span class="line">&#x2F;**</span><br><span class="line">* 若出现错误，error 中存放错误信息</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>

<ul>
<li>NSURLSessionDownloadDelegate（通常用于下载大量数据），遵守 NSURLSessionTaskDelegate 协议，常用的方法：</li>
</ul>
<p>1 . 写入数据到临时文件时调用的方法（服务器返回一点就写入一点）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:	(int64_t)totalBytesExpectedToWrite</span><br><span class="line">&#x2F;**</span><br><span class="line">* totalBytesWritten，已写入数据的总长度</span><br><span class="line">* totalBytesExpectedToWrite：总共要写入数据的总长度</span><br><span class="line">* 可以在该方法中计算下载进度</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>

<p>2 . 遇到错误的时候调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error</span><br></pre></td></tr></table></figure>

<p>3 . 用于断点下载的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* fileOffset：继续下载时，文件的开始位置</span><br><span class="line">* expectedTotalBytes：剩余的数据总数</span><br><span class="line">*&#x2F;</span><br><span class="line">- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didResumeAtOffset:(int64_t)fileOffset expectedTotalBytes:(int64_t)expectedTotalBytes</span><br></pre></td></tr></table></figure>

<p>4 . 下载完成时调用的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* location：下载的文件保存的临时位置</span><br><span class="line">* 需要将下载的文件保存在可以长期保存的位置</span><br><span class="line">*&#x2F;</span><br><span class="line">- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(NSURL *)location</span><br></pre></td></tr></table></figure>

<h3 id="使用-AFURLSessionManagerTaskDelegate-管理进度"><a href="#使用-AFURLSessionManagerTaskDelegate-管理进度" class="headerlink" title="使用 AFURLSessionManagerTaskDelegate 管理进度"></a>使用 <code>AFURLSessionManagerTaskDelegate</code> 管理进度</h3><p>在上面我们提到过 <code>AFURLSessionManagerTaskDelegate</code> 类，它主要为 task 提供进度管理功能，并在 task 结束时回调， 也就是调用在 <code>- [AFURLSessionManager dataTaskWithRequest:uploadProgress:downloadProgress:completionHandler:] 等方法中传入的 completionHandler</code>。</p>
<p>我们首先分析一下 <code>AFURLSessionManagerTaskDelegate</code> 是如何对进度进行跟踪的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)setupProgressForTask:(NSURLSessionTask *)task &#123;</span><br><span class="line"></span><br><span class="line">    #1：设置在上传进度或者下载进度状态改变时的回调</span><br><span class="line">true</span><br><span class="line">    #2：KVO</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法的实现有两个部分，一部分是对代理持有的两个属性 <code>uploadProgress</code> 和 <code>downloadProgress</code> 设置回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">__weak __typeof__(task) weakTask &#x3D; task;</span><br><span class="line"></span><br><span class="line">self.uploadProgress.totalUnitCount &#x3D; task.countOfBytesExpectedToSend;</span><br><span class="line">[self.uploadProgress setCancellable:YES];</span><br><span class="line">[self.uploadProgress setCancellationHandler:^&#123;</span><br><span class="line">   __typeof__(weakTask) strongTask &#x3D; weakTask;</span><br><span class="line">   [strongTask cancel];</span><br><span class="line">&#125;];</span><br><span class="line">[self.uploadProgress setPausable:YES];</span><br><span class="line">[self.uploadProgress setPausingHandler:^&#123;</span><br><span class="line">   __typeof__(weakTask) strongTask &#x3D; weakTask;</span><br><span class="line">   [strongTask suspend];</span><br><span class="line">&#125;];</span><br><span class="line">if ([self.uploadProgress respondsToSelector:@selector(setResumingHandler:)]) &#123;</span><br><span class="line">   [self.uploadProgress setResumingHandler:^&#123;</span><br><span class="line">       __typeof__(weakTask) strongTask &#x3D; weakTask;</span><br><span class="line">       [strongTask resume];</span><br><span class="line">   &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只有对 <code>uploadProgress</code> 设置回调的代码，设置 <code>downloadProgress</code> 与这里完全相同</p>
<p>主要目的是在对应 <code>NSProgress</code> 的状态改变时，调用 <code>resume</code> <code>suspend</code> 等方法改变 task 的状态。</p>
<p>第二部分是对 <code>task</code> 和 <code>NSProgress</code> 属性进行键值观测：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[task addObserver:self</span><br><span class="line">      forKeyPath:NSStringFromSelector(@selector(countOfBytesReceived))</span><br><span class="line">         options:NSKeyValueObservingOptionNew</span><br><span class="line">         context:NULL];</span><br><span class="line">[task addObserver:self</span><br><span class="line">      forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))</span><br><span class="line">         options:NSKeyValueObservingOptionNew</span><br><span class="line">         context:NULL];</span><br><span class="line"></span><br><span class="line">[task addObserver:self</span><br><span class="line">      forKeyPath:NSStringFromSelector(@selector(countOfBytesSent))</span><br><span class="line">         options:NSKeyValueObservingOptionNew</span><br><span class="line">         context:NULL];</span><br><span class="line">[task addObserver:self</span><br><span class="line">      forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToSend))</span><br><span class="line">         options:NSKeyValueObservingOptionNew</span><br><span class="line">         context:NULL];</span><br><span class="line"></span><br><span class="line">[self.downloadProgress addObserver:self</span><br><span class="line">                       forKeyPath:NSStringFromSelector(@selector(fractionCompleted))</span><br><span class="line">                          options:NSKeyValueObservingOptionNew</span><br><span class="line">                          context:NULL];</span><br><span class="line">[self.uploadProgress addObserver:self</span><br><span class="line">                     forKeyPath:NSStringFromSelector(@selector(fractionCompleted))</span><br><span class="line">                        options:NSKeyValueObservingOptionNew</span><br><span class="line">                        context:NULL];</span><br></pre></td></tr></table></figure>


<p>在 <code>observeValueForKeypath:ofObject:change:context:</code> 方法中改变进度，并调用 block</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context &#123;</span><br><span class="line">    if ([object isKindOfClass:[NSURLSessionTask class]]) &#123;</span><br><span class="line">        if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesReceived))]) &#123;</span><br><span class="line">            self.downloadProgress.completedUnitCount &#x3D; [change[@&quot;new&quot;] longLongValue];</span><br><span class="line">        &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))]) &#123;</span><br><span class="line">            self.downloadProgress.totalUnitCount &#x3D; [change[@&quot;new&quot;] longLongValue];</span><br><span class="line">        &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesSent))]) &#123;</span><br><span class="line">            self.uploadProgress.completedUnitCount &#x3D; [change[@&quot;new&quot;] longLongValue];</span><br><span class="line">        &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesExpectedToSend))]) &#123;</span><br><span class="line">            self.uploadProgress.totalUnitCount &#x3D; [change[@&quot;new&quot;] longLongValue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if ([object isEqual:self.downloadProgress]) &#123;</span><br><span class="line">        if (self.downloadProgressBlock) &#123;</span><br><span class="line">            self.downloadProgressBlock(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if ([object isEqual:self.uploadProgress]) &#123;</span><br><span class="line">        if (self.uploadProgressBlock) &#123;</span><br><span class="line">            self.uploadProgressBlock(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代理方法-URLSession-task-didCompleteWithError"><a href="#代理方法-URLSession-task-didCompleteWithError" class="headerlink" title="代理方法 URLSession:task:didCompleteWithError:"></a>代理方法 <code>URLSession:task:didCompleteWithError:</code></h3><p>在每一个 <code>NSURLSessionTask</code> 结束时，都会在代理方法 <code>URLSession:task:didCompleteWithError:</code> 中：<br>1 . 调用传入的 <code>completionHander</code> block<br>2 . 发出 <code>AFNetworkingTaskDidCompleteNotification</code> 通知</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(__unused NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line">didCompleteWithError:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line">    #1：获取数据, 存储 &#96;responseSerializer&#96; 和 &#96;downloadFileURL&#96;</span><br><span class="line"></span><br><span class="line">    if (error) &#123;</span><br><span class="line">    	#2：在存在错误时调用 &#96;completionHandler&#96;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">truetrue#3：调用 &#96;completionHandler&#96;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是整个代理方法的骨架，先看一下最简单的第一部分代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">__block NSMutableDictionary *userInfo &#x3D; [NSMutableDictionary dictionary];</span><br><span class="line">userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] &#x3D; manager.responseSerializer;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 具体可以查看 #issue 2672。这里主要是针对大文件的时候，性能提升会很明显</span><br><span class="line">NSData *data &#x3D; nil;</span><br><span class="line">if (self.mutableData) &#123;</span><br><span class="line">   data &#x3D; [self.mutableData copy];</span><br><span class="line">   &#x2F;&#x2F; 此处不再需要 mutableData 了</span><br><span class="line">   self.mutableData &#x3D; nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (self.downloadFileURL) &#123;</span><br><span class="line">   userInfo[AFNetworkingTaskDidCompleteAssetPathKey] &#x3D; self.downloadFileURL;</span><br><span class="line">&#125; else if (data) &#123;</span><br><span class="line">   userInfo[AFNetworkingTaskDidCompleteResponseDataKey] &#x3D; data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来看第二部分：这部分代码从 <code>mutableData</code> 中取出了数据，设置了 <code>userInfo</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果 task 出错了，处理 error 信息</span><br><span class="line">&#x2F;&#x2F; 所以对应的观察者在处理 error 的时候，比如可以先判断 userInfo[AFNetworkingTaskDidCompleteErrorKey] 是否有值，有值的话，就说明是要处理 error</span><br><span class="line">userInfo[AFNetworkingTaskDidCompleteErrorKey] &#x3D; error;</span><br><span class="line"></span><br><span class="line">dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    if (self.completionHandler) &#123;</span><br><span class="line">        self.completionHandler(task.response, responseObject, error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果当前 <code>manager</code> 持有 <code>completionGroup</code> 或者 <code>completionQueue</code> 就使用它们。否则会创建一个 <code>dispatch_group_t</code> 并在主线程中调用 <code>completionHandler</code> 并发送通知（在主线程中）。<br>最后一部分：如果在执行当前 task 时没有遇到错误，那么先对数据进行序列化，然后同样调用 block 并发送通知。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(url_session_manager_processing_queue(), ^&#123;</span><br><span class="line">    NSError *serializationError &#x3D; nil;</span><br><span class="line">    &#x2F;&#x2F; 根据对应的 task 和 data 将 response data 解析成可用的数据格式，比如 JSON serializer 就将 data 解析成 JSON 格式</span><br><span class="line">    responseObject &#x3D; [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];</span><br><span class="line">    &#x2F;&#x2F; 注意如果有 downloadFileURL，意味着 data 存放在了磁盘上了，所以此处 responseObject 保存的是 data 存放位置，供后面 completionHandler 处理。没有 downloadFileURL，就直接使用内存中的解析后的 data 数据</span><br><span class="line">    if (self.downloadFileURL) &#123;</span><br><span class="line">        responseObject &#x3D; self.downloadFileURL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (responseObject) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] &#x3D; responseObject;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 序列化的时候出现错误</span><br><span class="line">    if (serializationError) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteErrorKey] &#x3D; serializationError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        if (self.completionHandler) &#123;</span><br><span class="line">            self.completionHandler(task.response, responseObject, serializationError);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>代理方法 <code>URLSession:dataTask:didReceiveData:</code> 和 <code>- URLSession:downloadTask:didFinishDownloadingToURL:</code></p>
<p>这两个代理方法分别会在收到数据或者完成下载对应文件时调用，作用分别是为 mutableData 追加数据和处理下载的文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(__unused NSURLSession *)session</span><br><span class="line">          dataTask:(__unused NSURLSessionDataTask *)dataTask</span><br><span class="line">    didReceiveData:(NSData *)data</span><br><span class="line">&#123;</span><br><span class="line">    [self.mutableData appendData:data];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">      downloadTask:(NSURLSessionDownloadTask *)downloadTask</span><br><span class="line">didFinishDownloadingToURL:(NSURL *)location</span><br><span class="line">&#123;</span><br><span class="line">    NSError *fileManagerError &#x3D; nil;</span><br><span class="line">    self.downloadFileURL &#x3D; nil;</span><br><span class="line"></span><br><span class="line">    if (self.downloadTaskDidFinishDownloading) &#123;</span><br><span class="line">        self.downloadFileURL &#x3D; self.downloadTaskDidFinishDownloading(session, downloadTask, location);</span><br><span class="line">        if (self.downloadFileURL) &#123;</span><br><span class="line">            [[NSFileManager defaultManager] moveItemAtURL:location toURL:self.downloadFileURL error:&amp;fileManagerError];</span><br><span class="line"></span><br><span class="line">            if (fileManagerError) &#123;</span><br><span class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-AFURLSessionTaskSwizzling-调剂方法"><a href="#使用-AFURLSessionTaskSwizzling-调剂方法" class="headerlink" title="使用 AFURLSessionTaskSwizzling 调剂方法"></a>使用 <code>AFURLSessionTaskSwizzling</code> 调剂方法</h3><p><code>AFURLSessionTaskSwizzling</code> 的唯一功能就是修改 <code>NSURLSessionTask</code> 的 <code>resume</code> 和 <code>suspend</code> 方法，使用下面的方法替换原有的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)af_resume &#123;</span><br><span class="line">    NSAssert([self respondsToSelector:@selector(state)], @&quot;Does not respond to state&quot;);</span><br><span class="line">    NSURLSessionTaskState state &#x3D; [self state];</span><br><span class="line">    [self af_resume];</span><br><span class="line"></span><br><span class="line">    if (state !&#x3D; NSURLSessionTaskStateRunning) &#123;</span><br><span class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidResumeNotification object:self];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)af_suspend &#123;</span><br><span class="line">    NSAssert([self respondsToSelector:@selector(state)], @&quot;Does not respond to state&quot;);</span><br><span class="line">    NSURLSessionTaskState state &#x3D; [self state];</span><br><span class="line">    [self af_suspend];</span><br><span class="line"></span><br><span class="line">    if (state !&#x3D; NSURLSessionTaskStateSuspended) &#123;</span><br><span class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidSuspendNotification object:self];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样做的目的是为了在方法 <code>resume</code> 或者 <code>suspend</code> 被调用时发出通知。</p>
<p>具体方法调剂的过程是在 <code>+ load</code> 方法中进行的</p>
<p><code>load</code> 方法只会在整个文件被引入时调用一次</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load &#123;</span><br><span class="line">    if (NSClassFromString(@&quot;NSURLSessionTask&quot;)) &#123;</span><br><span class="line">        NSURLSessionConfiguration *configuration &#x3D; [NSURLSessionConfiguration ephemeralSessionConfiguration];</span><br><span class="line">        &#x2F;&#x2F; 首先构建一个 NSURLSession 对象 session，再通过 session 构建出一个 _NSCFLocalDataTask 变量</span><br><span class="line">        NSURLSession * session &#x3D; [NSURLSession sessionWithConfiguration:configuration];</span><br><span class="line">#pragma GCC diagnostic push</span><br><span class="line">#pragma GCC diagnostic ignored &quot;-Wnonnull&quot;</span><br><span class="line">        NSURLSessionDataTask *localDataTask &#x3D; [session dataTaskWithURL:nil];</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">        &#x2F;&#x2F; 获取到 af_resume 实现的指针</span><br><span class="line">        IMP originalAFResumeIMP &#x3D; method_getImplementation(class_getInstanceMethod([self class], @selector(af_resume)));</span><br><span class="line">        Class currentClass &#x3D; [localDataTask class];</span><br><span class="line">        &#x2F;&#x2F; 检查当前 class 是否实现了 resume。如果实现了，继续第 4 步</span><br><span class="line">        while (class_getInstanceMethod(currentClass, @selector(resume))) &#123;</span><br><span class="line">            &#x2F;&#x2F; 获取到当前 class 的父类（superClass）</span><br><span class="line">            Class superClass &#x3D; [currentClass superclass];</span><br><span class="line">            &#x2F;&#x2F; 获取到当前 class 对于 resume 实现的指针</span><br><span class="line">            IMP classResumeIMP &#x3D; method_getImplementation(class_getInstanceMethod(currentClass, @selector(resume)));</span><br><span class="line">            &#x2F;&#x2F; 获取到父类对于 resume 实现的指针</span><br><span class="line">            IMP superclassResumeIMP &#x3D; method_getImplementation(class_getInstanceMethod(superClass, @selector(resume)));</span><br><span class="line">            &#x2F;&#x2F; 如果当前 class 对于 resume 的实现和父类不一样（类似 iOS 7 上的情况），并且当前 class 的 resume 实现和 af_resume 不一样，才进行 method swizzling</span><br><span class="line">            if (classResumeIMP !&#x3D; superclassResumeIMP &amp;&amp;</span><br><span class="line">                originalAFResumeIMP !&#x3D; classResumeIMP) &#123;</span><br><span class="line">                [self swizzleResumeAndSuspendMethodForClass:currentClass];</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 设置当前操作的 class 为其父类 class，重复步骤 3~8</span><br><span class="line">            currentClass &#x3D; [currentClass superclass];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [localDataTask cancel];</span><br><span class="line">        [session finishTasksAndInvalidate];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1 . 首先用 <code>NSClassFromString(@&quot;NSURLSessionTask&quot;)</code> 判断当前部署的 iOS 版本是否含有类 <code>NSURLSessionTask</code><br>2 . 因为 iOS 7 和 iOS 8 上对于 <code>NSURLSessionTask</code> 的实现不同，所以会通过 <code>- [NSURLSession dataTaskWithURL:]</code> 方法返回一个 NSURLSessionTask 实例<br>3 . 取得当前类 <code>AFURLSessionTaskSwizzling</code> 中的实现 af_resume<br>4 . 如果当前类 <code>currentClass</code>  <strong>有</strong> resume 方法<br>5 . 使用 <code>swizzleResumeAndSuspendMethodForClass:</code> 调剂该类的 resume 和 suspend 方法<br>6 . 如果当前类 <code>currentClass</code>  <strong>没有</strong> resume 方法,<code>currentClass = [currentClass superclass]</code></p>
<h3 id="引入-AFSecurityPolicy-保证请求的安全"><a href="#引入-AFSecurityPolicy-保证请求的安全" class="headerlink" title="引入 AFSecurityPolicy 保证请求的安全"></a>引入 <code>AFSecurityPolicy</code> 保证请求的安全</h3><p><code>AFSecurityPolicy</code> 是 AFNetworking 用来保证 HTTP 请求安全的类，它被 <code>AFURLSessionManager</code> 持有，如果你在 <code>AFURLSessionManager</code> 的实现文件中搜索 self.securityPolicy，你只会得到三条结果：</p>
<blockquote>
<p>初始化 <code>self.securityPolicy = [AFSecurityPolicy defaultPolicy]</code><br>收到连接层的验证请求时<br>任务接收到验证请求时</p>
</blockquote>
<p>在 API 调用上，后两者都调用了 <code>- [AFSecurityPolicy evaluateServerTrust:forDomain:]</code> 方法来判断当前服务器是否被信任，我们会在接下来的文章中具体介绍这个方法的实现的作用。</p>
<h3 id="引入-AFNetworkReachabilityManager-监控网络状态"><a href="#引入-AFNetworkReachabilityManager-监控网络状态" class="headerlink" title="引入 AFNetworkReachabilityManager 监控网络状态"></a>引入 <code>AFNetworkReachabilityManager</code> 监控网络状态</h3><p>与 <code>AFSecurityPolicy</code> 相同，<code>AFURLSessionManager</code> 对网络状态的监控是由 <code>AFNetworkReachabilityManager</code> 来负责的，它仅仅是持有一个 <code>AFNetworkReachabilityManager</code> 的对象。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li><code>AFURLSessionManager</code> 是对 NSURLSession 的封装</li>
<li>它通过 <code>- [AFURLSessionManager dataTaskWithRequest:completionHandler:]</code> 等接口创建 <code>NSURLSessionDataTask</code> 的实例</li>
<li>持有一个字典 <code>mutableTaskDelegatesKeyedByTaskIdentifier</code> 管理这些 data task 实例</li>
<li>引入 <code>AFURLSessionManagerTaskDelegate</code> 来对传入的 <code>uploadProgressBlock downloadProgressBlock completionHandler</code> 在合适的时间进行调用</li>
<li>实现了全部的代理方法来提供 block 接口</li>
<li>通过方法调剂在 data task 状态改变时，发出通知</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2016/06/13/AFN2-0%E4%B8%8E3-0%E6%AF%94%E8%BE%83(%E4%BA%8C)/" rel="prev" title="8-AFN2-0与3-0比较(二)">
      <i class="fa fa-chevron-left"></i> 8-AFN2-0与3-0比较(二)
    </a></div>
      <div class="post-nav-item">
    <a href="/2016/07/19/Runtime%E7%AE%80%E5%8D%95%E5%89%96%E6%9E%90/" rel="next" title="10-Runtime简单剖析">
      10-Runtime简单剖析 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#AFURLSessionManager"><span class="nav-number">1.</span> <span class="nav-text">AFURLSessionManager</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建和管理-NSURLSession"><span class="nav-number">2.</span> <span class="nav-text">创建和管理 NSURLSession</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#管理-NSURLSessionTask"><span class="nav-number">3.</span> <span class="nav-text">管理 NSURLSessionTask</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现-NSURLSessionDelegate-等协议中的代理方法"><span class="nav-number">4.</span> <span class="nav-text">实现 NSURLSessionDelegate 等协议中的代理方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-AFURLSessionManagerTaskDelegate-管理进度"><span class="nav-number">5.</span> <span class="nav-text">使用 AFURLSessionManagerTaskDelegate 管理进度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代理方法-URLSession-task-didCompleteWithError"><span class="nav-number">6.</span> <span class="nav-text">代理方法 URLSession:task:didCompleteWithError:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-AFURLSessionTaskSwizzling-调剂方法"><span class="nav-number">7.</span> <span class="nav-text">使用 AFURLSessionTaskSwizzling 调剂方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引入-AFSecurityPolicy-保证请求的安全"><span class="nav-number">8.</span> <span class="nav-text">引入 AFSecurityPolicy 保证请求的安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引入-AFNetworkReachabilityManager-监控网络状态"><span class="nav-number">9.</span> <span class="nav-text">引入 AFNetworkReachabilityManager 监控网络状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结"><span class="nav-number">10.</span> <span class="nav-text">小结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">赵小嘎</p>
  <div class="site-description" itemprop="description">赵小嘎在 Github 上的个人博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">赵小嘎</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
